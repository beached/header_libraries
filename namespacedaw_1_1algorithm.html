<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DAW Header Libraries: daw::algorithm Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DAW Header Libraries
   </div>
   <div id="projectbrief">Variousheaderonlylibrariesandexperiments</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedaw.html">daw</a></li><li class="navelem"><a class="el" href="namespacedaw_1_1algorithm.html">algorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">daw::algorithm Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedaw_1_1algorithm_1_1_d_a_w___a_t_t_r_i_b___h_i_d_d_e_n"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm_1_1_d_a_w___a_t_t_r_i_b___h_i_d_d_e_n.html">DAW_ATTRIB_HIDDEN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1all__equal.html">all_equal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1find__one__of__result.html">find_one_of_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1find__some__result.html">find_some_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1tuple__functor.html">tuple_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1tuple__functor_3_010_01_4.html">tuple_functor&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a17cad1abe1563cc332baadc8286e5c70"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:a17cad1abe1563cc332baadc8286e5c70"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a17cad1abe1563cc332baadc8286e5c70">accumulate</a> (Container const &amp;container, T init)</td></tr>
<tr class="separator:a17cad1abe1563cc332baadc8286e5c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082b21807c0d80ccf68ad6de449b9943"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T , typename BinaryOperator , std::enable_if_t&lt; daw::traits::is_container_like_v&lt; std::remove_reference_t&lt; Container &gt;&gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a082b21807c0d80ccf68ad6de449b9943"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a082b21807c0d80ccf68ad6de449b9943">accumulate</a> (Container const &amp;container, T init, BinaryOperator oper)</td></tr>
<tr class="separator:a082b21807c0d80ccf68ad6de449b9943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2f99ef2a0c36731f352b3f5c0c860a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename T &gt; </td></tr>
<tr class="memitem:a4a2f99ef2a0c36731f352b3f5c0c860a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4a2f99ef2a0c36731f352b3f5c0c860a">accumulate</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> last, T init) noexcept</td></tr>
<tr class="separator:a4a2f99ef2a0c36731f352b3f5c0c860a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944826cf0164d4f289c579cd6668cda5"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename T , typename BinaryOperation  = std::plus&lt;&gt;, daw::enable_when_t&lt; not daw::traits::is_container_like_v&lt; InputIterator &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a944826cf0164d4f289c579cd6668cda5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a944826cf0164d4f289c579cd6668cda5">accumulate</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, LastType last, T init, BinaryOperation binary_op=BinaryOperation{ }) noexcept(noexcept(binary_op(<a class="el" href="daw__move_8h.html#a5707fa464976f991a156ac6a583a135c">DAW_MOVE</a>(init), *first)))</td></tr>
<tr class="separator:a944826cf0164d4f289c579cd6668cda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce45ed0b83d6e8567b52d36fc657f7c"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a5ce45ed0b83d6e8567b52d36fc657f7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a5ce45ed0b83d6e8567b52d36fc657f7c">adjacent_find</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate p)</td></tr>
<tr class="separator:a5ce45ed0b83d6e8567b52d36fc657f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66611fc5fedbe3d14da8ea48712e44e8"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a66611fc5fedbe3d14da8ea48712e44e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a66611fc5fedbe3d14da8ea48712e44e8">all_of</a> (InputIt first, InputIt last, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="separator:a66611fc5fedbe3d14da8ea48712e44e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e831e99ec1f0f3c7b138bb79df1ada"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a34e831e99ec1f0f3c7b138bb79df1ada"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a34e831e99ec1f0f3c7b138bb79df1ada">any_of</a> (InputIt first, InputIt last, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="separator:a34e831e99ec1f0f3c7b138bb79df1ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3c93707622a8f926e4e99dd578533b"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a6f3c93707622a8f926e4e99dd578533b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a6f3c93707622a8f926e4e99dd578533b">are_equal</a> (ValueType v1, ValueType v2)</td></tr>
<tr class="separator:a6f3c93707622a8f926e4e99dd578533b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526f0fd8877b4122a679ebf85e9553ae"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename... Values&gt; </td></tr>
<tr class="memitem:a526f0fd8877b4122a679ebf85e9553ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a526f0fd8877b4122a679ebf85e9553ae">are_equal</a> (ValueType v1, ValueType v2, Values... others)</td></tr>
<tr class="separator:a526f0fd8877b4122a679ebf85e9553ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a813d8fe12a8644442bdf00f0d1a26"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a55a813d8fe12a8644442bdf00f0d1a26"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a55a813d8fe12a8644442bdf00f0d1a26">are_equal</a> (ValueType) noexcept</td></tr>
<tr class="separator:a55a813d8fe12a8644442bdf00f0d1a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a64c490e32e63c61f3f9a36ef6337f4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Value , typename Predicate  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a0a64c490e32e63c61f3f9a36ef6337f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a0a64c490e32e63c61f3f9a36ef6337f4">binary_search</a> (ForwardIterator first, ForwardIterator const last, Value &amp;&amp;value, Predicate <a class="el" href="namespacedaw_1_1algorithm.html#a54e03635467f2e3edd2a5e22d130594c">less_than</a>=Predicate{ })</td></tr>
<tr class="separator:a0a64c490e32e63c61f3f9a36ef6337f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348a380774f14182c1f647ba814adfa7"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Iterator1 , typename LastType , typename... Iterators&gt; </td></tr>
<tr class="memitem:a348a380774f14182c1f647ba814adfa7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a348a380774f14182c1f647ba814adfa7">cartesian_product</a> (Function func, Iterator1 first1, LastType last1, Iterators... its)</td></tr>
<tr class="separator:a348a380774f14182c1f647ba814adfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a912de415d15db927d02ceaa983dd9"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Iterator1 , typename LastType , typename OutputIterator , typename... Iterators&gt; </td></tr>
<tr class="memitem:a83a912de415d15db927d02ceaa983dd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a83a912de415d15db927d02ceaa983dd9">cartesian_product_map</a> (Function func, Iterator1 first1, LastType last1, OutputIterator out_it, Iterators... its)</td></tr>
<tr class="separator:a83a912de415d15db927d02ceaa983dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21745db3448f2a269c864edf85bd62b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21745db3448f2a269c864edf85bd62b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a21745db3448f2a269c864edf85bd62b3">clamp</a> (T &amp;&amp;value, T &amp;&amp;max_value) noexcept</td></tr>
<tr class="separator:a21745db3448f2a269c864edf85bd62b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090d47b5916cea6cbd755fd3ef090e8e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename LessCompare  = std::less&lt;&gt;, typename Equality  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a090d47b5916cea6cbd755fd3ef090e8e"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a090d47b5916cea6cbd755fd3ef090e8e">compare_range</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, LessCompare less_comp=LessCompare{ }, Equality eq=Equality{ })</td></tr>
<tr class="separator:a090d47b5916cea6cbd755fd3ef090e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f192b6ccebd06eef1a7338e08b7c666"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class UnaryPredicate , typename Function &gt; </td></tr>
<tr class="memitem:a2f192b6ccebd06eef1a7338e08b7c666"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a2f192b6ccebd06eef1a7338e08b7c666">consume_if</a> (ForwardIterator first, ForwardIterator last, UnaryPredicate &amp;&amp;pred, Function &amp;&amp;func) noexcept(noexcept(<a class="el" href="namespacedaw.html#ab5eec8bf38fc54bec8b954609a724d8a">daw::invoke</a>(pred, *first)))</td></tr>
<tr class="separator:a2f192b6ccebd06eef1a7338e08b7c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd9bbb6df13f582f7b776fa07246f25"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Value &gt; </td></tr>
<tr class="memitem:a4bd9bbb6df13f582f7b776fa07246f25"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4bd9bbb6df13f582f7b776fa07246f25">contains</a> (Container const &amp;container, Value const &amp;value)</td></tr>
<tr class="separator:a4bd9bbb6df13f582f7b776fa07246f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecada20a15877d204ffc6b42dbb53ef"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Value , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:acecada20a15877d204ffc6b42dbb53ef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#acecada20a15877d204ffc6b42dbb53ef">contains</a> (Container const &amp;container, Value const &amp;value, UnaryPredicate pred)</td></tr>
<tr class="separator:acecada20a15877d204ffc6b42dbb53ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1404bf7eb1420ef148da26efa6f803d"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Last , typename Value , typename Compare  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:ae1404bf7eb1420ef148da26efa6f803d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ae1404bf7eb1420ef148da26efa6f803d">contains</a> (Iterator first, Last last, Value const &amp;value, Compare cmp=Compare{ })</td></tr>
<tr class="separator:ae1404bf7eb1420ef148da26efa6f803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b606fb08f1bc0ccd92715572f58f281"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Last , typename Predicate &gt; </td></tr>
<tr class="memitem:a3b606fb08f1bc0ccd92715572f58f281"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3b606fb08f1bc0ccd92715572f58f281">contains_if</a> (Iterator first, Last last, Predicate pred)</td></tr>
<tr class="separator:a3b606fb08f1bc0ccd92715572f58f281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3507b19c52691aee70a61f643650c963"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a3507b19c52691aee70a61f643650c963"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3507b19c52691aee70a61f643650c963">copy</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, LastType last, OutputIterator first_out) noexcept(noexcept(*first_out= *first))</td></tr>
<tr class="memdesc:a3507b19c52691aee70a61f643650c963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy input range [first, last) to output range [first_out, first_out + std::distance( first, last ))  <a href="namespacedaw_1_1algorithm.html#a3507b19c52691aee70a61f643650c963">More...</a><br /></td></tr>
<tr class="separator:a3507b19c52691aee70a61f643650c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b66509bae10796c6b1d708e6d164f8"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a98b66509bae10796c6b1d708e6d164f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a98b66509bae10796c6b1d708e6d164f8">copy_if</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, LastType last, OutputIterator destination, UnaryPredicate pred)</td></tr>
<tr class="memdesc:a98b66509bae10796c6b1d708e6d164f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy input range [first, last) to output range [first_out, first_out + std::distance( first, last ))  <a href="namespacedaw_1_1algorithm.html#a98b66509bae10796c6b1d708e6d164f8">More...</a><br /></td></tr>
<tr class="separator:a98b66509bae10796c6b1d708e6d164f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a00ad34966c36b58a030e80006c1128"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a5a00ad34966c36b58a030e80006c1128"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a5a00ad34966c36b58a030e80006c1128">copy_n</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, OutputIterator first_out, size_t count) noexcept(noexcept(*first_out= *first))</td></tr>
<tr class="memdesc:a5a00ad34966c36b58a030e80006c1128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy input range [first, last) to output range [first_out, first_out + count)  <a href="namespacedaw_1_1algorithm.html#a5a00ad34966c36b58a030e80006c1128">More...</a><br /></td></tr>
<tr class="separator:a5a00ad34966c36b58a030e80006c1128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f1366a0264fb7e78a69fd808323884"><td class="memTemplParams" colspan="2">template&lt;typename ResultType  = size_t, typename Iterator , typename Last , typename Predicate &gt; </td></tr>
<tr class="memitem:a32f1366a0264fb7e78a69fd808323884"><td class="memTemplItemLeft" align="right" valign="top">constexpr ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a32f1366a0264fb7e78a69fd808323884">count_if</a> (Iterator first, Last last, Predicate pred)</td></tr>
<tr class="separator:a32f1366a0264fb7e78a69fd808323884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7180d7d1c698717a28885b05c85dd3ac"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a7180d7d1c698717a28885b05c85dd3ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a7180d7d1c698717a28885b05c85dd3ac">crbegin2</a> (Container &amp;container) noexcept(noexcept(container.crbegin())) -&gt; decltype(container.crbegin())</td></tr>
<tr class="separator:a7180d7d1c698717a28885b05c85dd3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad36f82cf3ff81c74893fd7c225b469"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a7ad36f82cf3ff81c74893fd7c225b469"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a7ad36f82cf3ff81c74893fd7c225b469">crend2</a> (Container &amp;container) noexcept(noexcept(container.crend())) -&gt; decltype(container.crend())</td></tr>
<tr class="separator:a7ad36f82cf3ff81c74893fd7c225b469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c15180b57ad903b36d281236206748"><td class="memTemplParams" colspan="2">template&lt;std::size_t count, typename Function , typename... Args&gt; </td></tr>
<tr class="memitem:af5c15180b57ad903b36d281236206748"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="daw__attributes_8h.html#a09f8b09ddbbef2a5ae207ef8fa21c808">DAW_ATTRIB_FLATTEN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af5c15180b57ad903b36d281236206748">do_n</a> (Function &amp;&amp;func, Args &amp;&amp;...args)</td></tr>
<tr class="separator:af5c15180b57ad903b36d281236206748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eda9aec542d56ebfd1f6fc8c8665127"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename... Args&gt; </td></tr>
<tr class="memitem:a4eda9aec542d56ebfd1f6fc8c8665127"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="daw__attributes_8h.html#a09f8b09ddbbef2a5ae207ef8fa21c808">DAW_ATTRIB_FLATTEN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4eda9aec542d56ebfd1f6fc8c8665127">do_n</a> (std::size_t count, Function &amp;&amp;func, Args &amp;&amp;...args) noexcept(std::is_nothrow_invocable_v&lt; Function, Args... &gt;)</td></tr>
<tr class="separator:a4eda9aec542d56ebfd1f6fc8c8665127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df9a03459b14049d93749d6ece05e80"><td class="memTemplParams" colspan="2">template&lt;std::size_t count, std::size_t by_n = 1, typename Function , typename... Args&gt; </td></tr>
<tr class="memitem:a7df9a03459b14049d93749d6ece05e80"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="daw__attributes_8h.html#a09f8b09ddbbef2a5ae207ef8fa21c808">DAW_ATTRIB_FLATTEN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a7df9a03459b14049d93749d6ece05e80">do_n_arg</a> (Function &amp;&amp;func) noexcept(std::is_nothrow_invocable_v&lt; Function, std::size_t &gt;)</td></tr>
<tr class="separator:a7df9a03459b14049d93749d6ece05e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857528be3a4c30f2acb3e49fafad3a1c"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename... Args&gt; </td></tr>
<tr class="memitem:a857528be3a4c30f2acb3e49fafad3a1c"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="daw__attributes_8h.html#a09f8b09ddbbef2a5ae207ef8fa21c808">DAW_ATTRIB_FLATTEN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a857528be3a4c30f2acb3e49fafad3a1c">do_n_arg</a> (std::size_t count, Function &amp;&amp;func) noexcept(std::is_nothrow_invocable_v&lt; Function, std::size_t &gt;)</td></tr>
<tr class="separator:a857528be3a4c30f2acb3e49fafad3a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246406c231020051364312c9eb824ad7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType , typename InputIterator2 &gt; </td></tr>
<tr class="memitem:a246406c231020051364312c9eb824ad7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a246406c231020051364312c9eb824ad7">equal</a> (InputIterator1 first1, LastType last1, InputIterator2 first2)</td></tr>
<tr class="memdesc:a246406c231020051364312c9eb824ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two ranges [first1, last1) and [first2, first2 + std::distance( first1, last1 )) are equal.  <a href="namespacedaw_1_1algorithm.html#a246406c231020051364312c9eb824ad7">More...</a><br /></td></tr>
<tr class="separator:a246406c231020051364312c9eb824ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d098bbb4a1afa6660dbf3153330b15a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename Compare  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a8d098bbb4a1afa6660dbf3153330b15a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a8d098bbb4a1afa6660dbf3153330b15a">equal</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, Compare comp=Compare{ })</td></tr>
<tr class="memdesc:a8d098bbb4a1afa6660dbf3153330b15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two ranges [first1, last1) and [first2, last2) using pred.  <a href="namespacedaw_1_1algorithm.html#a8d098bbb4a1afa6660dbf3153330b15a">More...</a><br /></td></tr>
<tr class="separator:a8d098bbb4a1afa6660dbf3153330b15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cf92a01383de6938e84056452e8a05"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:ac1cf92a01383de6938e84056452e8a05"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac1cf92a01383de6938e84056452e8a05">equal_to</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:ac1cf92a01383de6938e84056452e8a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is equal to value construct with.  <a href="namespacedaw_1_1algorithm.html#ac1cf92a01383de6938e84056452e8a05">More...</a><br /></td></tr>
<tr class="separator:ac1cf92a01383de6938e84056452e8a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6de12815fd538cbb26349b7c94a910e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Value &gt; </td></tr>
<tr class="memitem:ad6de12815fd538cbb26349b7c94a910e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ad6de12815fd538cbb26349b7c94a910e">erase_remove</a> (Container &amp;container, Value const &amp;value) -&gt; decltype(container.erase(std::end(container), std::end(container)))</td></tr>
<tr class="separator:ad6de12815fd538cbb26349b7c94a910e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5ed077db75abb2a8992bf0bca9916"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:af2c5ed077db75abb2a8992bf0bca9916"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af2c5ed077db75abb2a8992bf0bca9916">erase_remove_if</a> (Container &amp;container, UnaryPredicate pred) -&gt; decltype(container.erase(std::end(container), std::end(container)))</td></tr>
<tr class="separator:af2c5ed077db75abb2a8992bf0bca9916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3380b4219cf95fb5b74f441afc16e05"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:ac3380b4219cf95fb5b74f441afc16e05"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac3380b4219cf95fb5b74f441afc16e05">extract_all</a> (From &amp;from, To &amp;to)</td></tr>
<tr class="separator:ac3380b4219cf95fb5b74f441afc16e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8316026229df93894eb788b14510ca"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To , typename Predicate &gt; </td></tr>
<tr class="memitem:afa8316026229df93894eb788b14510ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#afa8316026229df93894eb788b14510ca">extract_matching</a> (From &amp;from, To &amp;to, Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:afa8316026229df93894eb788b14510ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d032668855cbd0593ca1393fb4b101"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To , typename Query &gt; </td></tr>
<tr class="memitem:a19d032668855cbd0593ca1393fb4b101"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a19d032668855cbd0593ca1393fb4b101">extract_to</a> (From &amp;from, To &amp;to, Query &amp;&amp;q)</td></tr>
<tr class="separator:a19d032668855cbd0593ca1393fb4b101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8010cb04005c183297ce128a7b145d3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename T &gt; </td></tr>
<tr class="memitem:ac8010cb04005c183297ce128a7b145d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac8010cb04005c183297ce128a7b145d3">fill</a> (ForwardIterator first, LastType last, T &amp;&amp;value) noexcept</td></tr>
<tr class="separator:ac8010cb04005c183297ce128a7b145d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13372842c98a0c5fa1c9412a96fcee9"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ab13372842c98a0c5fa1c9412a96fcee9"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ab13372842c98a0c5fa1c9412a96fcee9">fill_n</a> (ForwardIterator first, size_t count, T &amp;&amp;value) noexcept</td></tr>
<tr class="separator:ab13372842c98a0c5fa1c9412a96fcee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc9286cd4fd352ead3af0501d143cc9"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Value , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:adcc9286cd4fd352ead3af0501d143cc9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#adcc9286cd4fd352ead3af0501d143cc9">find</a> (Container &amp;container, Value const &amp;value) noexcept(noexcept(std::find(std::begin(container), std::end(container), value)))</td></tr>
<tr class="separator:adcc9286cd4fd352ead3af0501d143cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6e4a4761407851259fe325a79d43ba"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Value , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a5d6e4a4761407851259fe325a79d43ba"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a5d6e4a4761407851259fe325a79d43ba">find</a> (Container const &amp;container, Value const &amp;value) noexcept(noexcept(std::find(std::begin(container), std::end(container), value)))</td></tr>
<tr class="separator:a5d6e4a4761407851259fe325a79d43ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06482e2d72b0abd493f5f06b8bc3ec"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a9f06482e2d72b0abd493f5f06b8bc3ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a9f06482e2d72b0abd493f5f06b8bc3ec">find</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> last, T const &amp;value)</td></tr>
<tr class="separator:a9f06482e2d72b0abd493f5f06b8bc3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d08fe8bdbb44123d9900af874c5b4a5"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a4d08fe8bdbb44123d9900af874c5b4a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4d08fe8bdbb44123d9900af874c5b4a5">find_first_of</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> last, ForwardIterator sfirst, ForwardIterator slast)</td></tr>
<tr class="separator:a4d08fe8bdbb44123d9900af874c5b4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14820bbe71e6c36f83a44266f1351fea"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a14820bbe71e6c36f83a44266f1351fea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a14820bbe71e6c36f83a44266f1351fea">find_first_of</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> last, UnaryPredicate pred)</td></tr>
<tr class="separator:a14820bbe71e6c36f83a44266f1351fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9421dd35db72d4a8d1ccc2f5a576c1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aff9421dd35db72d4a8d1ccc2f5a576c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aff9421dd35db72d4a8d1ccc2f5a576c1">find_first_range_of</a> (Iterator first, Iterator const last, UnaryPredicate pred)</td></tr>
<tr class="separator:aff9421dd35db72d4a8d1ccc2f5a576c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0631e95aa46582df7d713c3710c48b1"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ad0631e95aa46582df7d713c3710c48b1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ad0631e95aa46582df7d713c3710c48b1">find_if</a> (Container &amp;container, UnaryPredicate pred) noexcept(noexcept(std::find_if(std::begin(container), std::end(container), pred)))</td></tr>
<tr class="separator:ad0631e95aa46582df7d713c3710c48b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad372116e7c167c1ee0bad81b9b5fa28"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aad372116e7c167c1ee0bad81b9b5fa28"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aad372116e7c167c1ee0bad81b9b5fa28">find_if</a> (Container const &amp;container, UnaryPredicate pred) noexcept(noexcept(std::find_if(std::begin(container), std::end(container), pred)))</td></tr>
<tr class="separator:aad372116e7c167c1ee0bad81b9b5fa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107922750a7d50071fff62745825ba6d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename InputIteratorLast , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a107922750a7d50071fff62745825ba6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a107922750a7d50071fff62745825ba6d">find_if</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, InputIteratorLast last, UnaryPredicate &amp;&amp;unary_predicate)</td></tr>
<tr class="separator:a107922750a7d50071fff62745825ba6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd788ba1aab1318928d89a64aef094a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a1cd788ba1aab1318928d89a64aef094a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a1cd788ba1aab1318928d89a64aef094a">find_if_not</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> last, UnaryPredicate &amp;&amp;unary_predicate)</td></tr>
<tr class="separator:a1cd788ba1aab1318928d89a64aef094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0895670e01db5c74181a6a26ace22e4b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:a0895670e01db5c74181a6a26ace22e4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a0895670e01db5c74181a6a26ace22e4b">find_index</a> (Iterator first, Iterator last, T const &amp;value)</td></tr>
<tr class="separator:a0895670e01db5c74181a6a26ace22e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49df3aa19b5d30ce7f018213549367c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ab49df3aa19b5d30ce7f018213549367c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ab49df3aa19b5d30ce7f018213549367c">find_index_if</a> (Iterator first, Iterator last, Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:ab49df3aa19b5d30ce7f018213549367c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605d5f9e4d2ac3c7339817d614f0d259"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename IteratorLast , typename Value &gt; </td></tr>
<tr class="memitem:a605d5f9e4d2ac3c7339817d614f0d259"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a605d5f9e4d2ac3c7339817d614f0d259">find_index_of</a> (Iterator first, IteratorLast last, Value const &amp;v)</td></tr>
<tr class="separator:a605d5f9e4d2ac3c7339817d614f0d259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054f2fc6592a4b795b3b9c3900144048"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename IteratorLast , typename Predicate &gt; </td></tr>
<tr class="memitem:a054f2fc6592a4b795b3b9c3900144048"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a054f2fc6592a4b795b3b9c3900144048">find_index_of_if</a> (Iterator first, IteratorLast last, Predicate pred)</td></tr>
<tr class="separator:a054f2fc6592a4b795b3b9c3900144048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a78b56b4a11e134c5dfb9e317519be"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aa3a78b56b4a11e134c5dfb9e317519be"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aa3a78b56b4a11e134c5dfb9e317519be">find_last_of</a> (ForwardIterator first, ForwardIterator const last, UnaryPredicate pred)</td></tr>
<tr class="separator:aa3a78b56b4a11e134c5dfb9e317519be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ecf4a930f958b9190a4ab1cf738c0b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename IteratorLast , typename... Predicates&gt; </td></tr>
<tr class="memitem:a42ecf4a930f958b9190a4ab1cf738c0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdaw_1_1algorithm_1_1find__one__of__result.html">find_one_of_result</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a42ecf4a930f958b9190a4ab1cf738c0b">find_one_of</a> (Iterator first, IteratorLast last, Predicates... preds)</td></tr>
<tr class="separator:a42ecf4a930f958b9190a4ab1cf738c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e61beb897641a94d20400972aa17243"><td class="memTemplParams" colspan="2">template&lt;typename IteratorF , typename IteratorL , typename... Predicates&gt; </td></tr>
<tr class="memitem:a8e61beb897641a94d20400972aa17243"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structdaw_1_1algorithm_1_1find__some__result.html">find_some_result</a>&lt; IteratorF, sizeof...(Predicates)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a8e61beb897641a94d20400972aa17243">find_some</a> (IteratorF first, IteratorL last, Predicates &amp;&amp;...preds)</td></tr>
<tr class="separator:a8e61beb897641a94d20400972aa17243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27487c6c7d5f7603dd35efa431c3ea6b"><td class="memTemplParams" colspan="2">template&lt;typename RandomIterator , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a27487c6c7d5f7603dd35efa431c3ea6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a27487c6c7d5f7603dd35efa431c3ea6b">find_unsorted</a> (<a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a> first, <a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a> last, Compare comp=Compare{ })</td></tr>
<tr class="separator:a27487c6c7d5f7603dd35efa431c3ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae909b17db10006c20761ac386f5bbb"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Predicate , typename OnEach &gt; </td></tr>
<tr class="memitem:a3ae909b17db10006c20761ac386f5bbb"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3ae909b17db10006c20761ac386f5bbb">for_each_if</a> (Iterator first, Iterator last, Predicate pred, OnEach onEach)</td></tr>
<tr class="memdesc:a3ae909b17db10006c20761ac386f5bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a predicate is satisfied, call onEach with the read value.  <a href="namespacedaw_1_1algorithm.html#a3ae909b17db10006c20761ac386f5bbb">More...</a><br /></td></tr>
<tr class="separator:a3ae909b17db10006c20761ac386f5bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f5d2227d8c9e154951a177ae86cb8"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a925f5d2227d8c9e154951a177ae86cb8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; ForwardIterator, ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a925f5d2227d8c9e154951a177ae86cb8">gather</a> (ForwardIterator first, ForwardIterator last, ForwardIterator target, Predicate predicate)</td></tr>
<tr class="separator:a925f5d2227d8c9e154951a177ae86cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a6bcb616b2870be290d9f9b7870733"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a31a6bcb616b2870be290d9f9b7870733"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a31a6bcb616b2870be290d9f9b7870733">greater_than</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:a31a6bcb616b2870be290d9f9b7870733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is greater than the value constructed with.  <a href="namespacedaw_1_1algorithm.html#a31a6bcb616b2870be290d9f9b7870733">More...</a><br /></td></tr>
<tr class="separator:a31a6bcb616b2870be290d9f9b7870733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc10d9c646795a2f99e6f22ce4108313"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:afc10d9c646795a2f99e6f22ce4108313"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#afc10d9c646795a2f99e6f22ce4108313">greater_than_or_equal_to</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:afc10d9c646795a2f99e6f22ce4108313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is greater than or equal to the value constructed with.  <a href="namespacedaw_1_1algorithm.html#afc10d9c646795a2f99e6f22ce4108313">More...</a><br /></td></tr>
<tr class="separator:afc10d9c646795a2f99e6f22ce4108313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870e8b9cb223d68f886824b9a6ed6cbd"><td class="memTemplParams" colspan="2">template&lt;typename Lower , typename Upper &gt; </td></tr>
<tr class="memitem:a870e8b9cb223d68f886824b9a6ed6cbd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a870e8b9cb223d68f886824b9a6ed6cbd">in_range</a> (Lower &amp;&amp;lower, Upper &amp;&amp;upper)</td></tr>
<tr class="memdesc:a870e8b9cb223d68f886824b9a6ed6cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if the value passed is in the range [Lower, Upper].  <a href="namespacedaw_1_1algorithm.html#a870e8b9cb223d68f886824b9a6ed6cbd">More...</a><br /></td></tr>
<tr class="separator:a870e8b9cb223d68f886824b9a6ed6cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb32b7361c18f6dd2a7dac4a158044a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename EndIterator , typename T &gt; </td></tr>
<tr class="memitem:a2cb32b7361c18f6dd2a7dac4a158044a"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a2cb32b7361c18f6dd2a7dac4a158044a">iota</a> (Iterator first, EndIterator last, T start_value)</td></tr>
<tr class="separator:a2cb32b7361c18f6dd2a7dac4a158044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f54470b45dba1e12229ce4c9c67ae76"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename EndIterator , typename T , typename Setter &gt; </td></tr>
<tr class="memitem:a4f54470b45dba1e12229ce4c9c67ae76"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4f54470b45dba1e12229ce4c9c67ae76">iota</a> (Iterator first, EndIterator last, T start_value, Setter setter)</td></tr>
<tr class="separator:a4f54470b45dba1e12229ce4c9c67ae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9879e8a4c8d33f22a3b8c77504a01898"><td class="memTemplParams" colspan="2">template&lt;typename Ptr &gt; </td></tr>
<tr class="memitem:a9879e8a4c8d33f22a3b8c77504a01898"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a9879e8a4c8d33f22a3b8c77504a01898">is_null_ptr</a> (Ptr const *const ptr) noexcept</td></tr>
<tr class="separator:a9879e8a4c8d33f22a3b8c77504a01898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e700e320d0a724be3dee6bb0578418"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a18e700e320d0a724be3dee6bb0578418"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a18e700e320d0a724be3dee6bb0578418">is_sorted</a> (ForwardIterator first, LastType last, Compare comp=Compare{ }) noexcept(noexcept(comp(*first, *first)))</td></tr>
<tr class="separator:a18e700e320d0a724be3dee6bb0578418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af352d0f3c7349e76832859c5990225fa"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:af352d0f3c7349e76832859c5990225fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af352d0f3c7349e76832859c5990225fa">is_sorted_until</a> (ForwardIterator first, ForwardIterator last, Compare comp=Compare{ }) noexcept(noexcept(comp(*first, *first)))</td></tr>
<tr class="memdesc:af352d0f3c7349e76832859c5990225fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in ascending order.  <a href="namespacedaw_1_1algorithm.html#af352d0f3c7349e76832859c5990225fa">More...</a><br /></td></tr>
<tr class="separator:af352d0f3c7349e76832859c5990225fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4097b557f4ac677bf241413b41aaa8ef"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a4097b557f4ac677bf241413b41aaa8ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4097b557f4ac677bf241413b41aaa8ef">is_sorted_until</a> (ForwardIterator first, LastType last, Compare comp=Compare{ }) noexcept(noexcept(comp(*first, *first)))</td></tr>
<tr class="separator:a4097b557f4ac677bf241413b41aaa8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e03635467f2e3edd2a5e22d130594c"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a54e03635467f2e3edd2a5e22d130594c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a54e03635467f2e3edd2a5e22d130594c">less_than</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:a54e03635467f2e3edd2a5e22d130594c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is less than the value constructed with.  <a href="namespacedaw_1_1algorithm.html#a54e03635467f2e3edd2a5e22d130594c">More...</a><br /></td></tr>
<tr class="separator:a54e03635467f2e3edd2a5e22d130594c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918f6bdda424bc90d3a2f78e0c29a4a0"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a918f6bdda424bc90d3a2f78e0c29a4a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a918f6bdda424bc90d3a2f78e0c29a4a0">less_than_or_equal_to</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:a918f6bdda424bc90d3a2f78e0c29a4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is less than or equal to the value constructed with.  <a href="namespacedaw_1_1algorithm.html#a918f6bdda424bc90d3a2f78e0c29a4a0">More...</a><br /></td></tr>
<tr class="separator:a918f6bdda424bc90d3a2f78e0c29a4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7296f91f3fc8a8bbf1db649ab8b4f91e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a7296f91f3fc8a8bbf1db649ab8b4f91e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a7296f91f3fc8a8bbf1db649ab8b4f91e">lexicographical_compare</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, Compare comp=Compare{ }) noexcept(noexcept(comp(*first1, *first2) !=comp(*first2, *first1)))</td></tr>
<tr class="memdesc:a7296f91f3fc8a8bbf1db649ab8b4f91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first range [first1, last1) is lexigraphically less than the second range [first2, last2)  <a href="namespacedaw_1_1algorithm.html#a7296f91f3fc8a8bbf1db649ab8b4f91e">More...</a><br /></td></tr>
<tr class="separator:a7296f91f3fc8a8bbf1db649ab8b4f91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6248697fdfb467e6156d382a9651000"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Value , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:ab6248697fdfb467e6156d382a9651000"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ab6248697fdfb467e6156d382a9651000">lower_bound</a> (ForwardIterator first, ForwardIterator last, Value &amp;&amp;value, Compare cmp={ })</td></tr>
<tr class="separator:ab6248697fdfb467e6156d382a9651000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619bcf2d83e2e2c7e3583499c6b0b647"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a619bcf2d83e2e2c7e3583499c6b0b647"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a619bcf2d83e2e2c7e3583499c6b0b647">map</a> (Container const &amp;container, OutputIterator &amp;&amp;first_out, UnaryOperator unary_operator) noexcept(noexcept(std::transform(std::cbegin(container), std::cend(container), first_out, unary_operator)))</td></tr>
<tr class="separator:a619bcf2d83e2e2c7e3583499c6b0b647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac469c02e86ab80e61d6e69a69d3a263f"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ac469c02e86ab80e61d6e69a69d3a263f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac469c02e86ab80e61d6e69a69d3a263f">map</a> (Container const &amp;container, OutputIterator &amp;first_out, UnaryOperator unary_operator) noexcept(noexcept(std::transform(std::cbegin(container), std::cend(container), first_out, unary_operator)))</td></tr>
<tr class="separator:ac469c02e86ab80e61d6e69a69d3a263f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af074c7c6904f52974f0c932396178b7e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:af074c7c6904f52974f0c932396178b7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af074c7c6904f52974f0c932396178b7e">map</a> (Container const &amp;container, UnaryOperator unary_operator)</td></tr>
<tr class="separator:af074c7c6904f52974f0c932396178b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e353a0bcfae6ff014273ee36625c5c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:aa8e353a0bcfae6ff014273ee36625c5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aa8e353a0bcfae6ff014273ee36625c5c">map</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> const last, OutputIterator first_out, UnaryOperation unary_op) noexcept(noexcept(*<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first_out)=unary_op(*<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first))))</td></tr>
<tr class="separator:aa8e353a0bcfae6ff014273ee36625c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0e16fb0f656262688fe8efb808328f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a9d0e16fb0f656262688fe8efb808328f"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a9d0e16fb0f656262688fe8efb808328f">map</a> (InputIterator1 first1, InputIterator1 const last1, InputIterator2 first2, OutputIterator first_out, BinaryOperation binary_op) noexcept(noexcept(*<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first_out)=binary_op(*<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first1), *<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first2))))</td></tr>
<tr class="separator:a9d0e16fb0f656262688fe8efb808328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b614738de5163d3705ff9fdc0e0d4f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator1Last , typename InputIterator2 , typename T , typename ReduceFunction , typename MapFunction &gt; </td></tr>
<tr class="memitem:a07b614738de5163d3705ff9fdc0e0d4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a07b614738de5163d3705ff9fdc0e0d4f">map_reduce</a> (InputIterator1 first1, InputIterator1Last last1, InputIterator2 first2, T init, ReduceFunction reduce_func, MapFunction map_func) noexcept(noexcept(reduce_func(init, map_func(*first1, *first2))))</td></tr>
<tr class="separator:a07b614738de5163d3705ff9fdc0e0d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ec71a7d3ba746c143afebc4d4f2eac"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ad0ec71a7d3ba746c143afebc4d4f2eac"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ad0ec71a7d3ba746c143afebc4d4f2eac">max_element</a> (Container &amp;container) noexcept(noexcept(std::max_element(std::cbegin(container), std::cend(container))))</td></tr>
<tr class="separator:ad0ec71a7d3ba746c143afebc4d4f2eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35697b5b84faaa6f860bc6b8210eeeb7"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a35697b5b84faaa6f860bc6b8210eeeb7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a35697b5b84faaa6f860bc6b8210eeeb7">max_element</a> (Container &amp;container, Compare compare) noexcept(noexcept(std::max_element(std::begin(container), std::end(container), compare)))</td></tr>
<tr class="separator:a35697b5b84faaa6f860bc6b8210eeeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf823be79ecbc8592c396d38ccc2264"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename OutputIterator , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a1cf823be79ecbc8592c396d38ccc2264"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a1cf823be79ecbc8592c396d38ccc2264">max_element</a> (Container const &amp;container) noexcept(noexcept(std::max_element(std::cbegin(container), std::cend(container))))</td></tr>
<tr class="separator:a1cf823be79ecbc8592c396d38ccc2264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762395f5a5c0420db89b5c5406b548be"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a762395f5a5c0420db89b5c5406b548be"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a762395f5a5c0420db89b5c5406b548be">max_element</a> (Container const &amp;container, Compare compare) noexcept(noexcept(std::max_element(std::begin(container), std::end(container), compare)))</td></tr>
<tr class="separator:a762395f5a5c0420db89b5c5406b548be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c7c25ed11d5c2976ddc6eba620fb8"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:ac44c7c25ed11d5c2976ddc6eba620fb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac44c7c25ed11d5c2976ddc6eba620fb8">max_element</a> (ForwardIterator first, ForwardIterator last, Compare &amp;&amp;comp=Compare{ })</td></tr>
<tr class="separator:ac44c7c25ed11d5c2976ddc6eba620fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11533c815c7ef59f68b9eaf28be8b7e0"><td class="memTemplParams" colspan="2">template&lt;typename Lhs &gt; </td></tr>
<tr class="memitem:a11533c815c7ef59f68b9eaf28be8b7e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a11533c815c7ef59f68b9eaf28be8b7e0">max_item</a> (Lhs const &amp;lhs) noexcept</td></tr>
<tr class="separator:a11533c815c7ef59f68b9eaf28be8b7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae6f90fae33e1038d7cdf4988df6643"><td class="memTemplParams" colspan="2">template&lt;typename Lhs , typename... Ts, daw::enable_when_t&lt;(sizeof...(Ts) &gt; 0)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a6ae6f90fae33e1038d7cdf4988df6643"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a6ae6f90fae33e1038d7cdf4988df6643">max_item</a> (Lhs const &amp;lhs, Ts const &amp;...ts) noexcept</td></tr>
<tr class="separator:a6ae6f90fae33e1038d7cdf4988df6643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13564b7fa7f7bb24fb8447f9b88457d"><td class="memTemplParams" colspan="2">template&lt;typename Lhs &gt; </td></tr>
<tr class="memitem:ad13564b7fa7f7bb24fb8447f9b88457d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ad13564b7fa7f7bb24fb8447f9b88457d">min_item</a> (Lhs const &amp;lhs) noexcept</td></tr>
<tr class="separator:ad13564b7fa7f7bb24fb8447f9b88457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666c27cfee2abf06ba23825dfad9739d"><td class="memTemplParams" colspan="2">template&lt;typename Lhs , typename... Ts, daw::enable_when_t&lt;(sizeof...(Ts) &gt; 0)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a666c27cfee2abf06ba23825dfad9739d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a666c27cfee2abf06ba23825dfad9739d">min_item</a> (Lhs const &amp;lhs, Ts const &amp;...ts) noexcept</td></tr>
<tr class="separator:a666c27cfee2abf06ba23825dfad9739d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bf17243f1114998ba23aac7f5bdcec"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a96bf17243f1114998ba23aac7f5bdcec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a96bf17243f1114998ba23aac7f5bdcec">minmax_element</a> (ForwardIterator first, LastType last, Compare comp=Compare{ }) noexcept(noexcept(comp(*first, *first)))</td></tr>
<tr class="separator:a96bf17243f1114998ba23aac7f5bdcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e424d2a4b80fc2a5d7f956670b24036"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a4e424d2a4b80fc2a5d7f956670b24036"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4e424d2a4b80fc2a5d7f956670b24036">minmax_item</a> (T a, T b, Compare comp=Compare{ }) noexcept</td></tr>
<tr class="memdesc:a4e424d2a4b80fc2a5d7f956670b24036"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the min and max of two items sorted  <a href="namespacedaw_1_1algorithm.html#a4e424d2a4b80fc2a5d7f956670b24036">More...</a><br /></td></tr>
<tr class="separator:a4e424d2a4b80fc2a5d7f956670b24036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cc7fd2597e2ff7aa90f65271dae2e6"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ad2cc7fd2597e2ff7aa90f65271dae2e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ad2cc7fd2597e2ff7aa90f65271dae2e6">move</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, LastType const last, OutputIterator first_out) noexcept(noexcept(*first_out=<a class="el" href="daw__move_8h.html#a5707fa464976f991a156ac6a583a135c">DAW_MOVE</a>(*first)))</td></tr>
<tr class="memdesc:ad2cc7fd2597e2ff7aa90f65271dae2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move values from input range [first, last) to output range [first_out, std::distance( first, last))  <a href="namespacedaw_1_1algorithm.html#ad2cc7fd2597e2ff7aa90f65271dae2e6">More...</a><br /></td></tr>
<tr class="separator:ad2cc7fd2597e2ff7aa90f65271dae2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10898183c4796c63bdf78afb724b3ff0"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a10898183c4796c63bdf78afb724b3ff0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a10898183c4796c63bdf78afb724b3ff0">move_n</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, OutputIterator first_out, size_t count) noexcept(noexcept(*first_out=<a class="el" href="daw__move_8h.html#a5707fa464976f991a156ac6a583a135c">DAW_MOVE</a>(*first)))</td></tr>
<tr class="memdesc:a10898183c4796c63bdf78afb724b3ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move values from input range [first, last) to output range [first_out, first_out + count)  <a href="namespacedaw_1_1algorithm.html#a10898183c4796c63bdf78afb724b3ff0">More...</a><br /></td></tr>
<tr class="separator:a10898183c4796c63bdf78afb724b3ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3048b1af33a628f53d0215c2d9c13350"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a3048b1af33a628f53d0215c2d9c13350"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3048b1af33a628f53d0215c2d9c13350">none_of</a> (InputIt first, InputIt last, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="separator:a3048b1af33a628f53d0215c2d9c13350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf0fc9776642df4c7ffdf6b35ab80ad"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType , typename InputIterator2 &gt; </td></tr>
<tr class="memitem:aabf0fc9776642df4c7ffdf6b35ab80ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aabf0fc9776642df4c7ffdf6b35ab80ad">not_equal</a> (InputIterator1 first1, LastType last1, InputIterator2 first2)</td></tr>
<tr class="memdesc:aabf0fc9776642df4c7ffdf6b35ab80ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two ranges [first1, last1) and [first2, first2 + std::distance( first1, last1 )) are equal.  <a href="namespacedaw_1_1algorithm.html#aabf0fc9776642df4c7ffdf6b35ab80ad">More...</a><br /></td></tr>
<tr class="separator:aabf0fc9776642df4c7ffdf6b35ab80ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670de991496fd97b1760dbc45903af23"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename Compare  = std::not_equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a670de991496fd97b1760dbc45903af23"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a670de991496fd97b1760dbc45903af23">not_equal</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, Compare comp=Compare{ })</td></tr>
<tr class="memdesc:a670de991496fd97b1760dbc45903af23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two ranges [first1, last1) and [first2, last2) using pred.  <a href="namespacedaw_1_1algorithm.html#a670de991496fd97b1760dbc45903af23">More...</a><br /></td></tr>
<tr class="separator:a670de991496fd97b1760dbc45903af23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada02729717cfab7d8792c98fdd83d5f1"><td class="memTemplParams" colspan="2">template&lt;typename RandomIterator , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:ada02729717cfab7d8792c98fdd83d5f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ada02729717cfab7d8792c98fdd83d5f1">nth_element</a> (<a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a> first, <a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a> nth, <a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a> const last, Compare comp=Compare{ }) noexcept(noexcept(comp(*first, *nth)) &amp;&amp;noexcept(<a class="el" href="namespacedaw.html#a5944253ecc3d912e3e470e1c4ab17c42">daw::cswap</a>(*first, *nth)))</td></tr>
<tr class="separator:ada02729717cfab7d8792c98fdd83d5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea63be89b34ecad9efac4efd09c514e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryOperator  = std::plus&lt;&gt;&gt; </td></tr>
<tr class="memitem:adea63be89b34ecad9efac4efd09c514e"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#adea63be89b34ecad9efac4efd09c514e">partial_sum</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> last, OutputIterator first_out, BinaryOperator op=BinaryOperator{ })</td></tr>
<tr class="separator:adea63be89b34ecad9efac4efd09c514e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566ba24803fb7b10013ddbb6cc1016e7"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a566ba24803fb7b10013ddbb6cc1016e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a566ba24803fb7b10013ddbb6cc1016e7">partition</a> (Container &amp;container, UnaryPredicate pred) -&gt; decltype(begin(container))</td></tr>
<tr class="separator:a566ba24803fb7b10013ddbb6cc1016e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa876ba54601c4e30a2037a845c776d11"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aa876ba54601c4e30a2037a845c776d11"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aa876ba54601c4e30a2037a845c776d11">partition</a> (ForwardIterator first, ForwardIterator last, UnaryPredicate &amp;&amp;unary_predicate)</td></tr>
<tr class="separator:aa876ba54601c4e30a2037a845c776d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2016dccce680b2fd954e7e83e2c7f18e"><td class="memTemplParams" colspan="2">template&lt;size_t MinSize = 1, typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:a2016dccce680b2fd954e7e83e2c7f18e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdaw_1_1view.html">daw::view</a>&lt; BidirectionalIterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a2016dccce680b2fd954e7e83e2c7f18e">partition_range</a> (BidirectionalIterator first, BidirectionalIterator last, size_t count)</td></tr>
<tr class="separator:a2016dccce680b2fd954e7e83e2c7f18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f374b624c0fa8cf2faea4569e641cab"><td class="memTemplParams" colspan="2">template&lt;size_t MinSize = 1, typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:a9f374b624c0fa8cf2faea4569e641cab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdaw_1_1view.html">daw::view</a>&lt; BidirectionalIterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a9f374b624c0fa8cf2faea4569e641cab">partition_range</a> (<a class="el" href="structdaw_1_1view.html">daw::view</a>&lt; BidirectionalIterator &gt; rng, size_t count)</td></tr>
<tr class="separator:a9f374b624c0fa8cf2faea4569e641cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dc5ab2970864d9126cfa3761c67089"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:af6dc5ab2970864d9126cfa3761c67089"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af6dc5ab2970864d9126cfa3761c67089">rbegin2</a> (Container &amp;container) noexcept(noexcept(container.rbegin())) -&gt; decltype(container.rbegin())</td></tr>
<tr class="separator:af6dc5ab2970864d9126cfa3761c67089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d03f2e8e610c08c3b62cf9aba10fc4a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename RandomIterator , typename RandomIteratorLast , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a0d03f2e8e610c08c3b62cf9aba10fc4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a0d03f2e8e610c08c3b62cf9aba10fc4a">reduce</a> (<a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a> first, RandomIteratorLast last, T init, BinaryOperation binary_op) noexcept(noexcept(init=binary_op(init, *first++)))</td></tr>
<tr class="separator:a0d03f2e8e610c08c3b62cf9aba10fc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7ac4effdfa4fadaa4b3aca4da36b7d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ade7ac4effdfa4fadaa4b3aca4da36b7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ade7ac4effdfa4fadaa4b3aca4da36b7d">remove</a> (ForwardIterator first, ForwardIterator last, T const &amp;value)</td></tr>
<tr class="separator:ade7ac4effdfa4fadaa4b3aca4da36b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641675b8cc5170dc309d7174bba53695"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a641675b8cc5170dc309d7174bba53695"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a641675b8cc5170dc309d7174bba53695">remove_if</a> (ForwardIterator first, ForwardIterator last, UnaryPredicate &amp;&amp;pred) noexcept(noexcept(<a class="el" href="namespacedaw.html#ab5eec8bf38fc54bec8b954609a724d8a">daw::invoke</a>(pred, *first)))</td></tr>
<tr class="separator:a641675b8cc5170dc309d7174bba53695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17895ecdb30772d8471144e47350d3e0"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a17895ecdb30772d8471144e47350d3e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a17895ecdb30772d8471144e47350d3e0">rend2</a> (Container &amp;container) noexcept(noexcept(container.rend())) -&gt; decltype(container.rend())</td></tr>
<tr class="separator:a17895ecdb30772d8471144e47350d3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36c227a8190a418258d5b491f551a72"><td class="memTemplParams" colspan="2">template&lt;typename Fwd &gt; </td></tr>
<tr class="memitem:af36c227a8190a418258d5b491f551a72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af36c227a8190a418258d5b491f551a72">reverse</a> (Fwd &amp;&amp;fwd) -&gt; decltype(algorithm_details::reverse_impl(fwd, int(0)))</td></tr>
<tr class="separator:af36c227a8190a418258d5b491f551a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7119401f9b35b8d8c333df7bac1eb76c"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType &gt; </td></tr>
<tr class="memitem:a7119401f9b35b8d8c333df7bac1eb76c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a7119401f9b35b8d8c333df7bac1eb76c">rotate</a> (ForwardIterator first, ForwardIterator middle, LastType last) noexcept(noexcept(<a class="el" href="namespacedaw.html#a5944253ecc3d912e3e470e1c4ab17c42">daw::cswap</a>(*first, *middle)))</td></tr>
<tr class="memdesc:a7119401f9b35b8d8c333df7bac1eb76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotation on a range of elements.  <a href="namespacedaw_1_1algorithm.html#a7119401f9b35b8d8c333df7bac1eb76c">More...</a><br /></td></tr>
<tr class="separator:a7119401f9b35b8d8c333df7bac1eb76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfb08f27b60ffc7031e8c71038cfc73"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Iterator2 , typename UnaryPredicate , typename... UnaryPredicates, daw::enable_when_t&lt; std::conjunction_v&lt; traits::is_dereferenceable&lt; Iterator2 &gt;, traits::is_equality_comparable&lt; daw::traits::deref_t&lt; Iterator2 &gt;&gt;&gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a0cfb08f27b60ffc7031e8c71038cfc73"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a0cfb08f27b60ffc7031e8c71038cfc73">satisfies_all</a> (Iterator first, Iterator2 last, UnaryPredicate &amp;&amp;func, UnaryPredicates &amp;&amp;...funcs) noexcept(noexcept(<a class="el" href="namespacedaw_1_1algorithm.html#a6fbb987aa9c647ee766c92a89dfa58a4">satisfies_one</a>(*first, func, funcs...)))</td></tr>
<tr class="memdesc:a0cfb08f27b60ffc7031e8c71038cfc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all function(s) returns true for all values in range.  <a href="namespacedaw_1_1algorithm.html#a0cfb08f27b60ffc7031e8c71038cfc73">More...</a><br /></td></tr>
<tr class="separator:a0cfb08f27b60ffc7031e8c71038cfc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadb413768e40a33315892b555d789e0"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aaadb413768e40a33315892b555d789e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aaadb413768e40a33315892b555d789e0">satisfies_all</a> (Value &amp;&amp;value, UnaryPredicate &amp;&amp;func) noexcept(noexcept(func(value)))</td></tr>
<tr class="memdesc:aaadb413768e40a33315892b555d789e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if function returns true for the value.  <a href="namespacedaw_1_1algorithm.html#aaadb413768e40a33315892b555d789e0">More...</a><br /></td></tr>
<tr class="separator:aaadb413768e40a33315892b555d789e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd15058c7a84e8b3fb14e71e415b5fa"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename UnaryPredicate , typename... UnaryPredicates&gt; </td></tr>
<tr class="memitem:aafd15058c7a84e8b3fb14e71e415b5fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aafd15058c7a84e8b3fb14e71e415b5fa">satisfies_all</a> (Value &amp;&amp;value, UnaryPredicate &amp;&amp;func, UnaryPredicates &amp;&amp;...funcs)</td></tr>
<tr class="memdesc:aafd15058c7a84e8b3fb14e71e415b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all function(s) returns true for the value.  <a href="namespacedaw_1_1algorithm.html#aafd15058c7a84e8b3fb14e71e415b5fa">More...</a><br /></td></tr>
<tr class="separator:aafd15058c7a84e8b3fb14e71e415b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f3d04f92b332d02a3d09a0bed966e6"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Iterator2 , typename UnaryPredicate , typename... UnaryPredicates, daw::enable_when_t&lt; std::conjunction_v&lt; traits::is_dereferenceable&lt; Iterator2 &gt;, traits::is_equality_comparable&lt; daw::traits::deref_t&lt; Iterator2 &gt;&gt;&gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a02f3d04f92b332d02a3d09a0bed966e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a02f3d04f92b332d02a3d09a0bed966e6">satisfies_one</a> (Iterator first, Iterator2 last, UnaryPredicate &amp;&amp;func, UnaryPredicates &amp;&amp;...funcs) noexcept(noexcept(satisfies_one(*first, func, funcs...)))</td></tr>
<tr class="memdesc:a02f3d04f92b332d02a3d09a0bed966e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any function returns true for any value in range.  <a href="namespacedaw_1_1algorithm.html#a02f3d04f92b332d02a3d09a0bed966e6">More...</a><br /></td></tr>
<tr class="separator:a02f3d04f92b332d02a3d09a0bed966e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbb987aa9c647ee766c92a89dfa58a4"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a6fbb987aa9c647ee766c92a89dfa58a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a6fbb987aa9c647ee766c92a89dfa58a4">satisfies_one</a> (Value &amp;&amp;value, UnaryPredicate &amp;&amp;func) noexcept(noexcept(func(value)))</td></tr>
<tr class="memdesc:a6fbb987aa9c647ee766c92a89dfa58a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any function returns true for the value.  <a href="namespacedaw_1_1algorithm.html#a6fbb987aa9c647ee766c92a89dfa58a4">More...</a><br /></td></tr>
<tr class="separator:a6fbb987aa9c647ee766c92a89dfa58a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f323e3f8e391bed4be78902876b0cc5"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename UnaryPredicate , typename... UnaryPredicates&gt; </td></tr>
<tr class="memitem:a4f323e3f8e391bed4be78902876b0cc5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4f323e3f8e391bed4be78902876b0cc5">satisfies_one</a> (Value &amp;&amp;value, UnaryPredicate &amp;&amp;func, UnaryPredicates &amp;&amp;...funcs)</td></tr>
<tr class="memdesc:a4f323e3f8e391bed4be78902876b0cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any function returns true for the value.  <a href="namespacedaw_1_1algorithm.html#a4f323e3f8e391bed4be78902876b0cc5">More...</a><br /></td></tr>
<tr class="separator:a4f323e3f8e391bed4be78902876b0cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39afc7d4832cc57b7c30d2cf15b26f8d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename Compare  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a39afc7d4832cc57b7c30d2cf15b26f8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a39afc7d4832cc57b7c30d2cf15b26f8d">search</a> (ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 s_first, ForwardIterator2 s_last, Compare comp=Compare{ }) noexcept(noexcept(not comp(*first, *s_first)))</td></tr>
<tr class="separator:a39afc7d4832cc57b7c30d2cf15b26f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a11f1eba0c20a57886c073282e245f8"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename OutputIterator , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a1a11f1eba0c20a57886c073282e245f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a1a11f1eba0c20a57886c073282e245f8">set_intersection</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, OutputIterator d_first, Compare &amp;&amp;comp=Compare{ }) noexcept(noexcept(comp(*first2, *first1)) and noexcept(comp(*first1, *first2)))</td></tr>
<tr class="separator:a1a11f1eba0c20a57886c073282e245f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f58b789aa4f592313969f3f5ac88d68"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a8f58b789aa4f592313969f3f5ac88d68"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; ForwardIterator, ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a8f58b789aa4f592313969f3f5ac88d68">slide</a> (ForwardIterator first, ForwardIterator last, ForwardIterator target)</td></tr>
<tr class="separator:a8f58b789aa4f592313969f3f5ac88d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e6374ecee31a3d5860518d09cc64d1"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a55e6374ecee31a3d5860518d09cc64d1"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a55e6374ecee31a3d5860518d09cc64d1">sort</a> (Container &amp;container) noexcept(noexcept(std::sort(std::begin(container), std::end(container))))</td></tr>
<tr class="separator:a55e6374ecee31a3d5860518d09cc64d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac832fc0c8968fc6f466a1e6ec37a3a2e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ac832fc0c8968fc6f466a1e6ec37a3a2e"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac832fc0c8968fc6f466a1e6ec37a3a2e">sort</a> (Container &amp;container, Compare compare) noexcept(noexcept(std::sort(std::begin(container), std::end(container), compare)))</td></tr>
<tr class="separator:ac832fc0c8968fc6f466a1e6ec37a3a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf409c6068ef2dc471f46becfec26232"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Value &gt; </td></tr>
<tr class="memitem:aaf409c6068ef2dc471f46becfec26232"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aaf409c6068ef2dc471f46becfec26232">split</a> (Iterator first, Iterator last, Value const &amp;value)</td></tr>
<tr class="separator:aaf409c6068ef2dc471f46becfec26232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d3df4c9be5533e07818f559125981f"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a60d3df4c9be5533e07818f559125981f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a60d3df4c9be5533e07818f559125981f">stable_partition</a> (Container &amp;container, UnaryPredicate pred) -&gt; decltype(begin(container))</td></tr>
<tr class="separator:a60d3df4c9be5533e07818f559125981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404824b87e278b18d53e232ddfc67892"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a404824b87e278b18d53e232ddfc67892"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a404824b87e278b18d53e232ddfc67892">stable_sort</a> (Container &amp;container) noexcept(noexcept(std::stable_sort(std::begin(container), std::end(container))))</td></tr>
<tr class="separator:a404824b87e278b18d53e232ddfc67892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9434215e39dd8d41f9c86dbc15bad52e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a9434215e39dd8d41f9c86dbc15bad52e"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a9434215e39dd8d41f9c86dbc15bad52e">stable_sort</a> (Container &amp;container, Compare compare) noexcept(noexcept(std::stable_sort(std::begin(container), std::end(container), compare)))</td></tr>
<tr class="separator:a9434215e39dd8d41f9c86dbc15bad52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad054e7ae76c97db42dcf1df8324300"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a3ad054e7ae76c97db42dcf1df8324300"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3ad054e7ae76c97db42dcf1df8324300">transform</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, LastType last, OutputIterator first_out, UnaryOperation unary_op) noexcept(std::is_nothrow_constructible_v&lt; decltype(*first_out), decltype(unary_op(*first))&gt;)</td></tr>
<tr class="memdesc:a3ad054e7ae76c97db42dcf1df8324300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform range [first, last) and output to range [first_out, first_out + std::distance( first, last ))  <a href="namespacedaw_1_1algorithm.html#a3ad054e7ae76c97db42dcf1df8324300">More...</a><br /></td></tr>
<tr class="separator:a3ad054e7ae76c97db42dcf1df8324300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1292d41269e8059fd8c4fd565f6df08b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename OutputIterator , typename UnaryPredicate , typename TransformFunction &gt; </td></tr>
<tr class="memitem:a1292d41269e8059fd8c4fd565f6df08b"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a1292d41269e8059fd8c4fd565f6df08b">transform_if</a> (ForwardIterator first, LastType const last, OutputIterator first_out, UnaryPredicate pred, TransformFunction trans)</td></tr>
<tr class="memdesc:a1292d41269e8059fd8c4fd565f6df08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the TransformFunction on the value referenced by range [first, last) when the predicate returns true for that value.  <a href="namespacedaw_1_1algorithm.html#a1292d41269e8059fd8c4fd565f6df08b">More...</a><br /></td></tr>
<tr class="separator:a1292d41269e8059fd8c4fd565f6df08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d6b07b72b208da43f982e51fe912e7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a32d6b07b72b208da43f982e51fe912e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a32d6b07b72b208da43f982e51fe912e7">transform_it</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, LastType last, OutputIterator first_out, BinaryOperation binary_op) noexcept(noexcept(first_out=binary_op(*first++, first_out)))</td></tr>
<tr class="memdesc:a32d6b07b72b208da43f982e51fe912e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform input range [first, last) to output range [first_out, first_out + std::distance(first, last)).  <a href="namespacedaw_1_1algorithm.html#a32d6b07b72b208da43f982e51fe912e7">More...</a><br /></td></tr>
<tr class="separator:a32d6b07b72b208da43f982e51fe912e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57d6d8db61ee7a9a6af8d30999acb19"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename InputIt3 , typename InputIt4 , typename InputIt5 , typename OutputIt , typename Func &gt; </td></tr>
<tr class="memitem:af57d6d8db61ee7a9a6af8d30999acb19"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af57d6d8db61ee7a9a6af8d30999acb19">transform_many</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt3 first3, InputIt4 first4, InputIt4 first5, OutputIt first_out, Func func)</td></tr>
<tr class="separator:af57d6d8db61ee7a9a6af8d30999acb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8a70d6c991394488d046801ae5e943"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename InputIt3 , typename InputIt4 , typename OutputIt , typename Func &gt; </td></tr>
<tr class="memitem:aab8a70d6c991394488d046801ae5e943"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aab8a70d6c991394488d046801ae5e943">transform_many</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt3 first3, InputIt4 first4, OutputIt first_out, Func func)</td></tr>
<tr class="separator:aab8a70d6c991394488d046801ae5e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae081a7fb4de4a66ada5795adc738196f"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename InputIt3 , typename OutputIt , typename Func &gt; </td></tr>
<tr class="memitem:ae081a7fb4de4a66ada5795adc738196f"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ae081a7fb4de4a66ada5795adc738196f">transform_many</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt3 first3, OutputIt first_out, Func func)</td></tr>
<tr class="separator:ae081a7fb4de4a66ada5795adc738196f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7626aa527e1bf8a47c22225d5c12e9"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Func &gt; </td></tr>
<tr class="memitem:a5d7626aa527e1bf8a47c22225d5c12e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a5d7626aa527e1bf8a47c22225d5c12e9">transform_many</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt first_out, Func func)</td></tr>
<tr class="separator:a5d7626aa527e1bf8a47c22225d5c12e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa485a04daaccb007febfd11ea60a80da"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:aa485a04daaccb007febfd11ea60a80da"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aa485a04daaccb007febfd11ea60a80da">transform_n</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, OutputIterator first_out, size_t count, UnaryOperation unary_op) noexcept(noexcept(*first_out=unary_op(*first)))</td></tr>
<tr class="memdesc:aa485a04daaccb007febfd11ea60a80da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the transform function unary_op on n elements of range started by first.  <a href="namespacedaw_1_1algorithm.html#aa485a04daaccb007febfd11ea60a80da">More...</a><br /></td></tr>
<tr class="separator:aa485a04daaccb007febfd11ea60a80da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5bdd633d26ab5d52424e7b7cdbe056"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a5e5bdd633d26ab5d52424e7b7cdbe056"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a5e5bdd633d26ab5d52424e7b7cdbe056">upper_bound</a> (ForwardIterator first, ForwardIterator last, T const &amp;value, Compare comp=Compare{ }) noexcept(noexcept(<a class="el" href="namespacedaw.html#a557cf75d8b8e24da975f31aa7a3dad69">daw::advance</a>(first, 1)) and noexcept(++first) and noexcept(<a class="el" href="namespacedaw.html#af12f9c7fb9774c53848cf8e9f721c828">daw::distance</a>(first, last)))</td></tr>
<tr class="memdesc:a5e5bdd633d26ab5d52424e7b7cdbe056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range [first, last) that is greater than value, or last if no such element is found.  <a href="namespacedaw_1_1algorithm.html#a5e5bdd633d26ab5d52424e7b7cdbe056">More...</a><br /></td></tr>
<tr class="separator:a5e5bdd633d26ab5d52424e7b7cdbe056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec592b6450f709e3666765ba90a5645"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:adec592b6450f709e3666765ba90a5645"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#adec592b6450f709e3666765ba90a5645">where</a> (Container &amp;container, UnaryPredicate predicate)</td></tr>
<tr class="separator:adec592b6450f709e3666765ba90a5645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbddafa5870ff0db531cae3f3b8b3526"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:adbddafa5870ff0db531cae3f3b8b3526"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#adbddafa5870ff0db531cae3f3b8b3526">where</a> (<a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> first, <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> last, UnaryPredicate predicate)</td></tr>
<tr class="separator:adbddafa5870ff0db531cae3f3b8b3526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a17cad1abe1563cc332baadc8286e5c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cad1abe1563cc332baadc8286e5c70">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T daw::algorithm::accumulate </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a082b21807c0d80ccf68ad6de449b9943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082b21807c0d80ccf68ad6de449b9943">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T , typename BinaryOperator , std::enable_if_t&lt; daw::traits::is_container_like_v&lt; std::remove_reference_t&lt; Container &gt;&gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T daw::algorithm::accumulate </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperator&#160;</td>
          <td class="paramname"><em>oper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a2f99ef2a0c36731f352b3f5c0c860a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2f99ef2a0c36731f352b3f5c0c860a">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::accumulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a944826cf0164d4f289c579cd6668cda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944826cf0164d4f289c579cd6668cda5">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename LastType , typename T , typename BinaryOperation  = std::plus&lt;&gt;, daw::enable_when_t&lt; not daw::traits::is_container_like_v&lt; InputIterator &gt;&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::accumulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em> = <code>BinaryOperation{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ce45ed0b83d6e8567b52d36fc657f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce45ed0b83d6e8567b52d36fc657f7c">&#9670;&nbsp;</a></span>adjacent_find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66611fc5fedbe3d14da8ea48712e44e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66611fc5fedbe3d14da8ea48712e44e8">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::all_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34e831e99ec1f0f3c7b138bb79df1ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e831e99ec1f0f3c7b138bb79df1ada">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::any_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f3c93707622a8f926e4e99dd578533b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3c93707622a8f926e4e99dd578533b">&#9670;&nbsp;</a></span>are_equal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::are_equal </td>
          <td>(</td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a526f0fd8877b4122a679ebf85e9553ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526f0fd8877b4122a679ebf85e9553ae">&#9670;&nbsp;</a></span>are_equal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename... Values&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::are_equal </td>
          <td>(</td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values...&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55a813d8fe12a8644442bdf00f0d1a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a813d8fe12a8644442bdf00f0d1a26">&#9670;&nbsp;</a></span>are_equal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::are_equal </td>
          <td>(</td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a64c490e32e63c61f3f9a36ef6337f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a64c490e32e63c61f3f9a36ef6337f4">&#9670;&nbsp;</a></span>binary_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Value , typename Predicate  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::binary_search </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>less_than</em> = <code>Predicate{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a348a380774f14182c1f647ba814adfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348a380774f14182c1f647ba814adfa7">&#9670;&nbsp;</a></span>cartesian_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Iterator1 , typename LastType , typename... Iterators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::cartesian_product </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterators...&#160;</td>
          <td class="paramname"><em>its</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83a912de415d15db927d02ceaa983dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a912de415d15db927d02ceaa983dd9">&#9670;&nbsp;</a></span>cartesian_product_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Iterator1 , typename LastType , typename OutputIterator , typename... Iterators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::cartesian_product_map </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterators...&#160;</td>
          <td class="paramname"><em>its</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21745db3448f2a269c864edf85bd62b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21745db3448f2a269c864edf85bd62b3">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T daw::algorithm::clamp </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a090d47b5916cea6cbd755fd3ef090e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090d47b5916cea6cbd755fd3ef090e8e">&#9670;&nbsp;</a></span>compare_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename LessCompare  = std::less&lt;&gt;, typename Equality  = std::equal_to&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int daw::algorithm::compare_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LessCompare&#160;</td>
          <td class="paramname"><em>less_comp</em> = <code>LessCompare{&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Equality&#160;</td>
          <td class="paramname"><em>eq</em> = <code>Equality{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f192b6ccebd06eef1a7338e08b7c666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f192b6ccebd06eef1a7338e08b7c666">&#9670;&nbsp;</a></span>consume_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class UnaryPredicate , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::consume_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bd9bbb6df13f582f7b776fa07246f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd9bbb6df13f582f7b776fa07246f25">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool daw::algorithm::contains </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acecada20a15877d204ffc6b42dbb53ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecada20a15877d204ffc6b42dbb53ef">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Value , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool daw::algorithm::contains </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1404bf7eb1420ef148da26efa6f803d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1404bf7eb1420ef148da26efa6f803d">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Last , typename Value , typename Compare  = std::equal_to&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::contains </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Last&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>cmp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b606fb08f1bc0ccd92715572f58f281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b606fb08f1bc0ccd92715572f58f281">&#9670;&nbsp;</a></span>contains_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Last , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::contains_if </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Last&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3507b19c52691aee70a61f643650c963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3507b19c52691aee70a61f643650c963">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename LastType , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy input range [first, last) to output range [first_out, first_out + std::distance( first, last )) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a></td><td>type of Iterator of input range </td></tr>
    <tr><td class="paramname">LastType</td><td>type of Iterator marking end of input range </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>type of iterator for output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>start of input range </td></tr>
    <tr><td class="paramname">last</td><td>end of input range </td></tr>
    <tr><td class="paramname">first_out</td><td>first item in output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end of output range written to </dd></dl>

</div>
</div>
<a id="a98b66509bae10796c6b1d708e6d164f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b66509bae10796c6b1d708e6d164f8">&#9670;&nbsp;</a></span>copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename LastType , typename OutputIterator , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::copy_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy input range [first, last) to output range [first_out, first_out + std::distance( first, last )) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a></td><td>type of Iterator of input range </td></tr>
    <tr><td class="paramname">LastType</td><td>type of Iterator marking end of input range </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>type of iterator for output range </td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>type predicate determining if to copy element </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>start of input range </td></tr>
    <tr><td class="paramname">last</td><td>end of input range </td></tr>
    <tr><td class="paramname">destination</td><td>first item in output range </td></tr>
    <tr><td class="paramname">pred</td><td>A unary predicate that determines if a copy is done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end of output range written to </dd></dl>

</div>
</div>
<a id="a5a00ad34966c36b58a030e80006c1128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a00ad34966c36b58a030e80006c1128">&#9670;&nbsp;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::copy_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy input range [first, last) to output range [first_out, first_out + count) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a></td><td>type of Iterator of input range </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>type of iterator for output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>start of input range </td></tr>
    <tr><td class="paramname">first_out</td><td>first item in output range </td></tr>
    <tr><td class="paramname">count</td><td>number of items to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end of output range written to </dd></dl>

</div>
</div>
<a id="a32f1366a0264fb7e78a69fd808323884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f1366a0264fb7e78a69fd808323884">&#9670;&nbsp;</a></span>count_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType  = size_t, typename Iterator , typename Last , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ResultType daw::algorithm::count_if </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Last&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7180d7d1c698717a28885b05c85dd3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7180d7d1c698717a28885b05c85dd3ac">&#9670;&nbsp;</a></span>crbegin2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::crbegin2 </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; decltype( container.crbegin( ) ) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ad36f82cf3ff81c74893fd7c225b469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad36f82cf3ff81c74893fd7c225b469">&#9670;&nbsp;</a></span>crend2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::crend2 </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; decltype( container.crend( ) ) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5c15180b57ad903b36d281236206748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c15180b57ad903b36d281236206748">&#9670;&nbsp;</a></span>do_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t count, typename Function , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="daw__attributes_8h.html#a09f8b09ddbbef2a5ae207ef8fa21c808">DAW_ATTRIB_FLATTEN</a> void daw::algorithm::do_n </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4eda9aec542d56ebfd1f6fc8c8665127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eda9aec542d56ebfd1f6fc8c8665127">&#9670;&nbsp;</a></span>do_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="daw__attributes_8h.html#a09f8b09ddbbef2a5ae207ef8fa21c808">DAW_ATTRIB_FLATTEN</a> void daw::algorithm::do_n </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7df9a03459b14049d93749d6ece05e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df9a03459b14049d93749d6ece05e80">&#9670;&nbsp;</a></span>do_n_arg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t count, std::size_t by_n = 1, typename Function , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="daw__attributes_8h.html#a09f8b09ddbbef2a5ae207ef8fa21c808">DAW_ATTRIB_FLATTEN</a> void daw::algorithm::do_n_arg </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a857528be3a4c30f2acb3e49fafad3a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857528be3a4c30f2acb3e49fafad3a1c">&#9670;&nbsp;</a></span>do_n_arg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="daw__attributes_8h.html#a09f8b09ddbbef2a5ae207ef8fa21c808">DAW_ATTRIB_FLATTEN</a> void daw::algorithm::do_n_arg </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a246406c231020051364312c9eb824ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246406c231020051364312c9eb824ad7">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename LastType , typename InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if two ranges [first1, last1) and [first2, first2 + std::distance( first1, last1 )) are equal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>type of Iterator of first input range </td></tr>
    <tr><td class="paramname">LastType</td><td>type of Iterator marking end of first input range </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>type of Iterator of second input range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>start of first input range </td></tr>
    <tr><td class="paramname">last1</td><td>end of first input range </td></tr>
    <tr><td class="paramname">first2</td><td>start of second input range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both ranges are equal </dd></dl>

</div>
</div>
<a id="a8d098bbb4a1afa6660dbf3153330b15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d098bbb4a1afa6660dbf3153330b15a">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename Compare  = std::equal_to&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if two ranges [first1, last1) and [first2, last2) using pred. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>type of Iterator of first input range </td></tr>
    <tr><td class="paramname">LastType1</td><td>type of Iterator marking end of first input range </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>type of Iterator of second input range </td></tr>
    <tr><td class="paramname">LastType2</td><td>type of Iterator marking end of second input range </td></tr>
    <tr><td class="paramname">Compare</td><td>type of predicate fullfilling Compare concept </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>start of first input range </td></tr>
    <tr><td class="paramname">last1</td><td>end of first input range </td></tr>
    <tr><td class="paramname">first2</td><td>start of second input range </td></tr>
    <tr><td class="paramname">last2</td><td>end of second input range </td></tr>
    <tr><td class="paramname">comp</td><td>predicate to determine equality of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both ranges are equal </dd></dl>

</div>
</div>
<a id="ac1cf92a01383de6938e84056452e8a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cf92a01383de6938e84056452e8a05">&#9670;&nbsp;</a></span>equal_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::equal_to </td>
          <td>(</td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable that returns true if value passed is equal to value construct with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to test with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value passed to operator( ) is equal to value constructed with </dd></dl>

</div>
</div>
<a id="ad6de12815fd538cbb26349b7c94a910e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6de12815fd538cbb26349b7c94a910e">&#9670;&nbsp;</a></span>erase_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto daw::algorithm::erase_remove </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( container.erase( std::end( container ),
	                                std::end( container ) ) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2c5ed077db75abb2a8992bf0bca9916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c5ed077db75abb2a8992bf0bca9916">&#9670;&nbsp;</a></span>erase_remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto daw::algorithm::erase_remove_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( container.erase( std::end( container ),
	                                std::end( container ) ) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3380b4219cf95fb5b74f441afc16e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3380b4219cf95fb5b74f441afc16e05">&#9670;&nbsp;</a></span>extract_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::extract_all </td>
          <td>(</td>
          <td class="paramtype">From &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">To &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa8316026229df93894eb788b14510ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8316026229df93894eb788b14510ca">&#9670;&nbsp;</a></span>extract_matching()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::extract_matching </td>
          <td>(</td>
          <td class="paramtype">From &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">To &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19d032668855cbd0593ca1393fb4b101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d032668855cbd0593ca1393fb4b101">&#9670;&nbsp;</a></span>extract_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename To , typename Query &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::extract_to </td>
          <td>(</td>
          <td class="paramtype">From &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">To &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query &amp;&amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8010cb04005c183297ce128a7b145d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8010cb04005c183297ce128a7b145d3">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename LastType , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab13372842c98a0c5fa1c9412a96fcee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13372842c98a0c5fa1c9412a96fcee9">&#9670;&nbsp;</a></span>fill_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::fill_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcc9286cd4fd352ead3af0501d143cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc9286cd4fd352ead3af0501d143cc9">&#9670;&nbsp;</a></span>find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Value , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) daw::algorithm::find </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d6e4a4761407851259fe325a79d43ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6e4a4761407851259fe325a79d43ba">&#9670;&nbsp;</a></span>find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Value , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) daw::algorithm::find </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f06482e2d72b0abd493f5f06b8bc3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f06482e2d72b0abd493f5f06b8bc3ec">&#9670;&nbsp;</a></span>find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> daw::algorithm::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d08fe8bdbb44123d9900af874c5b4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d08fe8bdbb44123d9900af874c5b4a5">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> daw::algorithm::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>sfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>slast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14820bbe71e6c36f83a44266f1351fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14820bbe71e6c36f83a44266f1351fea">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> daw::algorithm::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff9421dd35db72d4a8d1ccc2f5a576c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9421dd35db72d4a8d1ccc2f5a576c1">&#9670;&nbsp;</a></span>find_first_range_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::find_first_range_of </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0631e95aa46582df7d713c3710c48b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0631e95aa46582df7d713c3710c48b1">&#9670;&nbsp;</a></span>find_if() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) daw::algorithm::find_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad372116e7c167c1ee0bad81b9b5fa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad372116e7c167c1ee0bad81b9b5fa28">&#9670;&nbsp;</a></span>find_if() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) daw::algorithm::find_if </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a107922750a7d50071fff62745825ba6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107922750a7d50071fff62745825ba6d">&#9670;&nbsp;</a></span>find_if() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename InputIteratorLast , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> daw::algorithm::find_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIteratorLast&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>unary_predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cd788ba1aab1318928d89a64aef094a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd788ba1aab1318928d89a64aef094a">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> daw::algorithm::find_if_not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>unary_predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0895670e01db5c74181a6a26ace22e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0895670e01db5c74181a6a26ace22e4b">&#9670;&nbsp;</a></span>find_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt;size_t&gt; daw::algorithm::find_index </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab49df3aa19b5d30ce7f018213549367c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49df3aa19b5d30ce7f018213549367c">&#9670;&nbsp;</a></span>find_index_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt;size_t&gt; daw::algorithm::find_index_if </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a605d5f9e4d2ac3c7339817d614f0d259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605d5f9e4d2ac3c7339817d614f0d259">&#9670;&nbsp;</a></span>find_index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename IteratorLast , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t daw::algorithm::find_index_of </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorLast&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a054f2fc6592a4b795b3b9c3900144048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054f2fc6592a4b795b3b9c3900144048">&#9670;&nbsp;</a></span>find_index_of_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename IteratorLast , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t daw::algorithm::find_index_of_if </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorLast&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3a78b56b4a11e134c5dfb9e317519be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a78b56b4a11e134c5dfb9e317519be">&#9670;&nbsp;</a></span>find_last_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::find_last_of </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42ecf4a930f958b9190a4ab1cf738c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ecf4a930f958b9190a4ab1cf738c0b">&#9670;&nbsp;</a></span>find_one_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename IteratorLast , typename... Predicates&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdaw_1_1algorithm_1_1find__one__of__result.html">find_one_of_result</a>&lt;Iterator&gt; daw::algorithm::find_one_of </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorLast&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicates...&#160;</td>
          <td class="paramname"><em>preds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e61beb897641a94d20400972aa17243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e61beb897641a94d20400972aa17243">&#9670;&nbsp;</a></span>find_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorF , typename IteratorL , typename... Predicates&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structdaw_1_1algorithm_1_1find__some__result.html">find_some_result</a>&lt;IteratorF, sizeof...( Predicates )&gt; daw::algorithm::find_some </td>
          <td>(</td>
          <td class="paramtype">IteratorF&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorL&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicates &amp;&amp;...&#160;</td>
          <td class="paramname"><em>preds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27487c6c7d5f7603dd35efa431c3ea6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27487c6c7d5f7603dd35efa431c3ea6b">&#9670;&nbsp;</a></span>find_unsorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIterator , typename Compare  = std::less&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a> daw::algorithm::find_unsorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ae909b17db10006c20761ac386f5bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae909b17db10006c20761ac386f5bbb">&#9670;&nbsp;</a></span>for_each_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Predicate , typename OnEach &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::for_each_if </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnEach&#160;</td>
          <td class="paramname"><em>onEach</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When a predicate is satisfied, call onEach with the read value. </p>

</div>
</div>
<a id="a925f5d2227d8c9e154951a177ae86cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925f5d2227d8c9e154951a177ae86cb8">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;ForwardIterator, ForwardIterator&gt; daw::algorithm::gather </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31a6bcb616b2870be290d9f9b7870733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a6bcb616b2870be290d9f9b7870733">&#9670;&nbsp;</a></span>greater_than()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::greater_than </td>
          <td>(</td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable that returns true if value passed is greater than the value constructed with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to test with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value passed to operator( ) is greater than to value constructed with </dd></dl>

</div>
</div>
<a id="afc10d9c646795a2f99e6f22ce4108313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc10d9c646795a2f99e6f22ce4108313">&#9670;&nbsp;</a></span>greater_than_or_equal_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable that returns true if value passed is greater than or equal to the value constructed with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to test with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value passed to operator( ) is greater than or equal to to value constructed with </dd></dl>

</div>
</div>
<a id="a870e8b9cb223d68f886824b9a6ed6cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870e8b9cb223d68f886824b9a6ed6cbd">&#9670;&nbsp;</a></span>in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lower , typename Upper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::in_range </td>
          <td>(</td>
          <td class="paramtype">Lower &amp;&amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Upper &amp;&amp;&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable that returns true if the value passed is in the range [Lower, Upper]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower</td><td>The lowest value allowed </td></tr>
    <tr><td class="paramname">upper</td><td>The largest value allowed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value passed to operator( ) is within the range [lower, upper] </dd></dl>

</div>
</div>
<a id="a2cb32b7361c18f6dd2a7dac4a158044a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb32b7361c18f6dd2a7dac4a158044a">&#9670;&nbsp;</a></span>iota() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename EndIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::iota </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f54470b45dba1e12229ce4c9c67ae76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f54470b45dba1e12229ce4c9c67ae76">&#9670;&nbsp;</a></span>iota() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename EndIterator , typename T , typename Setter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::iota </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Setter&#160;</td>
          <td class="paramname"><em>setter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9879e8a4c8d33f22a3b8c77504a01898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9879e8a4c8d33f22a3b8c77504a01898">&#9670;&nbsp;</a></span>is_null_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ptr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::is_null_ptr </td>
          <td>(</td>
          <td class="paramtype">Ptr const *const&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18e700e320d0a724be3dee6bb0578418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e700e320d0a724be3dee6bb0578418">&#9670;&nbsp;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename LastType , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af352d0f3c7349e76832859c5990225fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af352d0f3c7349e76832859c5990225fa">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in ascending order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>Iterator type used to hold range </td></tr>
    <tr><td class="paramname">Compare</td><td>Comparision function object type that satifies the Compare concept </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first item in range </td></tr>
    <tr><td class="paramname">last</td><td>end of range </td></tr>
    <tr><td class="paramname">comp</td><td>comparision function object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ForwardIterator with the last sorted item </dd></dl>

</div>
</div>
<a id="a4097b557f4ac677bf241413b41aaa8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4097b557f4ac677bf241413b41aaa8ef">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename LastType , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54e03635467f2e3edd2a5e22d130594c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e03635467f2e3edd2a5e22d130594c">&#9670;&nbsp;</a></span>less_than()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::less_than </td>
          <td>(</td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable that returns true if value passed is less than the value constructed with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to test with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value passed to operator( ) is less than to value constructed with </dd></dl>

</div>
</div>
<a id="a918f6bdda424bc90d3a2f78e0c29a4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918f6bdda424bc90d3a2f78e0c29a4a0">&#9670;&nbsp;</a></span>less_than_or_equal_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a callable that returns true if value passed is less than or equal to the value constructed with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to test with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value passed to operator( ) is less than or equal to to value constructed with </dd></dl>

</div>
</div>
<a id="a7296f91f3fc8a8bbf1db649ab8b4f91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7296f91f3fc8a8bbf1db649ab8b4f91e">&#9670;&nbsp;</a></span>lexicographical_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the first range [first1, last1) is lexigraphically less than the second range [first2, last2) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>Iterator type for start of range 1 </td></tr>
    <tr><td class="paramname">LastType1</td><td>Type for value at end of range 1 </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>Iterator type for start of range 2 </td></tr>
    <tr><td class="paramname">LastType2</td><td>Type for value at end of range 2 </td></tr>
    <tr><td class="paramname">Compare</td><td>Type for comp callback that fullfills Compare concept </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>Start of range 1 </td></tr>
    <tr><td class="paramname">last1</td><td>End of range 1 </td></tr>
    <tr><td class="paramname">first2</td><td>Start of range 1 </td></tr>
    <tr><td class="paramname">last2</td><td>End of Range 1 </td></tr>
    <tr><td class="paramname">comp</td><td>Comparison function that returns true if value1 &lt; value2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true of range 1 is lexigraphically less than range 2 using supplied comparison </dd></dl>

</div>
</div>
<a id="ab6248697fdfb467e6156d382a9651000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6248697fdfb467e6156d382a9651000">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Value , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::lower_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>cmp</em> = <code>{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a619bcf2d83e2e2c7e3583499c6b0b647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619bcf2d83e2e2c7e3583499c6b0b647">&#9670;&nbsp;</a></span>map() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void daw::algorithm::map </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperator&#160;</td>
          <td class="paramname"><em>unary_operator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac469c02e86ab80e61d6e69a69d3a263f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac469c02e86ab80e61d6e69a69d3a263f">&#9670;&nbsp;</a></span>map() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void daw::algorithm::map </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator &amp;&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperator&#160;</td>
          <td class="paramname"><em>unary_operator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af074c7c6904f52974f0c932396178b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af074c7c6904f52974f0c932396178b7e">&#9670;&nbsp;</a></span>map() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto daw::algorithm::map </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperator&#160;</td>
          <td class="paramname"><em>unary_operator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8e353a0bcfae6ff014273ee36625c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e353a0bcfae6ff014273ee36625c5c">&#9670;&nbsp;</a></span>map() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename UnaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d0e16fb0f656262688fe8efb808328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0e16fb0f656262688fe8efb808328f">&#9670;&nbsp;</a></span>map() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::map </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1 const&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07b614738de5163d3705ff9fdc0e0d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b614738de5163d3705ff9fdc0e0d4f">&#9670;&nbsp;</a></span>map_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator1Last , typename InputIterator2 , typename T , typename ReduceFunction , typename MapFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T daw::algorithm::map_reduce </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1Last&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceFunction&#160;</td>
          <td class="paramname"><em>reduce_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapFunction&#160;</td>
          <td class="paramname"><em>map_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0ec71a7d3ba746c143afebc4d4f2eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ec71a7d3ba746c143afebc4d4f2eac">&#9670;&nbsp;</a></span>max_element() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) daw::algorithm::max_element </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a35697b5b84faaa6f860bc6b8210eeeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35697b5b84faaa6f860bc6b8210eeeb7">&#9670;&nbsp;</a></span>max_element() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Compare , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) daw::algorithm::max_element </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cf823be79ecbc8592c396d38ccc2264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf823be79ecbc8592c396d38ccc2264">&#9670;&nbsp;</a></span>max_element() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename OutputIterator , typename UnaryOperator , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) daw::algorithm::max_element </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a762395f5a5c0420db89b5c5406b548be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762395f5a5c0420db89b5c5406b548be">&#9670;&nbsp;</a></span>max_element() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Compare , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) daw::algorithm::max_element </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac44c7c25ed11d5c2976ddc6eba620fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44c7c25ed11d5c2976ddc6eba620fb8">&#9670;&nbsp;</a></span>max_element() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11533c815c7ef59f68b9eaf28be8b7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11533c815c7ef59f68b9eaf28be8b7e0">&#9670;&nbsp;</a></span>max_item() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const auto&amp; daw::algorithm::max_item </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ae6f90fae33e1038d7cdf4988df6643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae6f90fae33e1038d7cdf4988df6643">&#9670;&nbsp;</a></span>max_item() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs , typename... Ts, daw::enable_when_t&lt;(sizeof...(Ts) &gt; 0)&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const auto&amp; daw::algorithm::max_item </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts const &amp;...&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad13564b7fa7f7bb24fb8447f9b88457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13564b7fa7f7bb24fb8447f9b88457d">&#9670;&nbsp;</a></span>min_item() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const auto&amp; daw::algorithm::min_item </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a666c27cfee2abf06ba23825dfad9739d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666c27cfee2abf06ba23825dfad9739d">&#9670;&nbsp;</a></span>min_item() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lhs , typename... Ts, daw::enable_when_t&lt;(sizeof...(Ts) &gt; 0)&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const auto&amp; daw::algorithm::min_item </td>
          <td>(</td>
          <td class="paramtype">Lhs const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts const &amp;...&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96bf17243f1114998ba23aac7f5bdcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bf17243f1114998ba23aac7f5bdcec">&#9670;&nbsp;</a></span>minmax_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename LastType , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::minmax_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e424d2a4b80fc2a5d7f956670b24036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e424d2a4b80fc2a5d7f956670b24036">&#9670;&nbsp;</a></span>minmax_item()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt;T, T&gt; daw::algorithm::minmax_item </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the min and max of two items sorted </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>of items to evaluate </td></tr>
    <tr><td class="paramname">Compare</td><td>predicate that returns true if lhs &lt; rhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>item 1 </td></tr>
    <tr><td class="paramname">b</td><td>item 2 </td></tr>
    <tr><td class="paramname">comp</td><td>comparison predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::pair&lt;T, T&gt; that has the first member holding min(a, b) and second max(a, b) </dd></dl>

</div>
</div>
<a id="ad2cc7fd2597e2ff7aa90f65271dae2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cc7fd2597e2ff7aa90f65271dae2e6">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename LastType , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move values from input range [first, last) to output range [first_out, std::distance( first, last)) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a></td><td>type of Iterator of input range </td></tr>
    <tr><td class="paramname">LastType</td><td>type of Iterator marking end of input range </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>type of iterator for output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>start of input range </td></tr>
    <tr><td class="paramname">last</td><td>end of input range </td></tr>
    <tr><td class="paramname">first_out</td><td>first item in output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end of output range written to </dd></dl>

</div>
</div>
<a id="a10898183c4796c63bdf78afb724b3ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10898183c4796c63bdf78afb724b3ff0">&#9670;&nbsp;</a></span>move_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::move_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move values from input range [first, last) to output range [first_out, first_out + count) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a></td><td>type of Iterator of input range </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>type of iterator for output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>start of input range </td></tr>
    <tr><td class="paramname">first_out</td><td>first item in output range </td></tr>
    <tr><td class="paramname">count</td><td>number of items to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end of output range written to </dd></dl>

</div>
</div>
<a id="a3048b1af33a628f53d0215c2d9c13350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3048b1af33a628f53d0215c2d9c13350">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::none_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabf0fc9776642df4c7ffdf6b35ab80ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf0fc9776642df4c7ffdf6b35ab80ad">&#9670;&nbsp;</a></span>not_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename LastType , typename InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::not_equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if two ranges [first1, last1) and [first2, first2 + std::distance( first1, last1 )) are equal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>type of Iterator of first input range </td></tr>
    <tr><td class="paramname">LastType</td><td>type of Iterator marking end of first input range </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>type of Iterator of second input range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>start of first input range </td></tr>
    <tr><td class="paramname">last1</td><td>end of first input range </td></tr>
    <tr><td class="paramname">first2</td><td>start of second input range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both ranges are equal </dd></dl>

</div>
</div>
<a id="a670de991496fd97b1760dbc45903af23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670de991496fd97b1760dbc45903af23">&#9670;&nbsp;</a></span>not_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename Compare  = std::not_equal_to&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::not_equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if two ranges [first1, last1) and [first2, last2) using pred. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>type of Iterator of first input range </td></tr>
    <tr><td class="paramname">LastType1</td><td>type of Iterator marking end of first input range </td></tr>
    <tr><td class="paramname">InputIterator2</td><td>type of Iterator of second input range </td></tr>
    <tr><td class="paramname">LastType2</td><td>type of Iterator marking end of second input range </td></tr>
    <tr><td class="paramname">Compare</td><td>type of predicate fullfilling Compare concept </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>start of first input range </td></tr>
    <tr><td class="paramname">last1</td><td>end of first input range </td></tr>
    <tr><td class="paramname">first2</td><td>start of second input range </td></tr>
    <tr><td class="paramname">last2</td><td>end of second input range </td></tr>
    <tr><td class="paramname">comp</td><td>predicate to determine equality of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both ranges are equal </dd></dl>

</div>
</div>
<a id="ada02729717cfab7d8792c98fdd83d5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada02729717cfab7d8792c98fdd83d5f1">&#9670;&nbsp;</a></span>nth_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIterator , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::nth_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a>&#160;</td>
          <td class="paramname"><em>nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a> const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adea63be89b34ecad9efac4efd09c514e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea63be89b34ecad9efac4efd09c514e">&#9670;&nbsp;</a></span>partial_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename BinaryOperator  = std::plus&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::partial_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperator&#160;</td>
          <td class="paramname"><em>op</em> = <code>BinaryOperator{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a566ba24803fb7b10013ddbb6cc1016e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566ba24803fb7b10013ddbb6cc1016e7">&#9670;&nbsp;</a></span>partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto daw::algorithm::partition </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( begin( container ) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa876ba54601c4e30a2037a845c776d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa876ba54601c4e30a2037a845c776d11">&#9670;&nbsp;</a></span>partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::partition </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>unary_predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2016dccce680b2fd954e7e83e2c7f18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2016dccce680b2fd954e7e83e2c7f18e">&#9670;&nbsp;</a></span>partition_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MinSize = 1, typename BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structdaw_1_1view.html">daw::view</a>&lt;BidirectionalIterator&gt; &gt; daw::algorithm::partition_range </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f374b624c0fa8cf2faea4569e641cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f374b624c0fa8cf2faea4569e641cab">&#9670;&nbsp;</a></span>partition_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MinSize = 1, typename BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structdaw_1_1view.html">daw::view</a>&lt;BidirectionalIterator&gt; &gt; daw::algorithm::partition_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1view.html">daw::view</a>&lt; BidirectionalIterator &gt;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6dc5ab2970864d9126cfa3761c67089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dc5ab2970864d9126cfa3761c67089">&#9670;&nbsp;</a></span>rbegin2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::rbegin2 </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; decltype( container.rbegin( ) ) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d03f2e8e610c08c3b62cf9aba10fc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d03f2e8e610c08c3b62cf9aba10fc4a">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename RandomIterator , typename RandomIteratorLast , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T daw::algorithm::reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIteratorLast&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade7ac4effdfa4fadaa4b3aca4da36b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7ac4effdfa4fadaa4b3aca4da36b7d">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::remove </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a641675b8cc5170dc309d7174bba53695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641675b8cc5170dc309d7174bba53695">&#9670;&nbsp;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::remove_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17895ecdb30772d8471144e47350d3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17895ecdb30772d8471144e47350d3e0">&#9670;&nbsp;</a></span>rend2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::rend2 </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; decltype( container.rend( ) ) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af36c227a8190a418258d5b491f551a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36c227a8190a418258d5b491f551a72">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fwd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto daw::algorithm::reverse </td>
          <td>(</td>
          <td class="paramtype">Fwd &amp;&amp;&#160;</td>
          <td class="paramname"><em>fwd</em></td><td>)</td>
          <td> -&gt; decltype( algorithm_details::reverse_impl( fwd, int( 0 ) ) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7119401f9b35b8d8c333df7bac1eb76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7119401f9b35b8d8c333df7bac1eb76c">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename LastType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void daw::algorithm::rotate </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotation on a range of elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>type of Iterator for items in range </td></tr>
    <tr><td class="paramname">LastType</td><td>type that is equal to ForwardIterator when end of range reached </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first item in range </td></tr>
    <tr><td class="paramname">middle</td><td>middle of range, first item in new range </td></tr>
    <tr><td class="paramname">last</td><td>last item in range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cfb08f27b60ffc7031e8c71038cfc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfb08f27b60ffc7031e8c71038cfc73">&#9670;&nbsp;</a></span>satisfies_all() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Iterator2 , typename UnaryPredicate , typename... UnaryPredicates, daw::enable_when_t&lt; std::conjunction_v&lt; traits::is_dereferenceable&lt; Iterator2 &gt;, traits::is_equality_comparable&lt; daw::traits::deref_t&lt; Iterator2 &gt;&gt;&gt;&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::satisfies_all </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicates &amp;&amp;...&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all function(s) returns true for all values in range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the beginning of the range inclusively </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to the end of the range exclusively </td></tr>
    <tr><td class="paramname">func</td><td>A UnaryPredicate that returns true/false </td></tr>
    <tr><td class="paramname">funcs</td><td>UnaryPredicates that return true/false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any of the func/funcs return true(e.g. like OR) for any value in range </dd></dl>

</div>
</div>
<a id="aaadb413768e40a33315892b555d789e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadb413768e40a33315892b555d789e0">&#9670;&nbsp;</a></span>satisfies_all() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::satisfies_all </td>
          <td>(</td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if function returns true for the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><a class="el" href="structdaw_1_1_argument.html">Argument</a> to UnaryPredicate </td></tr>
    <tr><td class="paramname">func</td><td>A UnaryPredicate that returns true/false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of func </dd></dl>

</div>
</div>
<a id="aafd15058c7a84e8b3fb14e71e415b5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd15058c7a84e8b3fb14e71e415b5fa">&#9670;&nbsp;</a></span>satisfies_all() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value , typename UnaryPredicate , typename... UnaryPredicates&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::satisfies_all </td>
          <td>(</td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicates &amp;&amp;...&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all function(s) returns true for the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><a class="el" href="structdaw_1_1_argument.html">Argument</a> to UnaryPredicate(s) </td></tr>
    <tr><td class="paramname">func</td><td>A UnaryPredicate that returns true/false </td></tr>
    <tr><td class="paramname">funcs</td><td>UnaryPredicates that return true/false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any of the func/funcs return true(e.g. like OR) </dd></dl>

</div>
</div>
<a id="a02f3d04f92b332d02a3d09a0bed966e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f3d04f92b332d02a3d09a0bed966e6">&#9670;&nbsp;</a></span>satisfies_one() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Iterator2 , typename UnaryPredicate , typename... UnaryPredicates, daw::enable_when_t&lt; std::conjunction_v&lt; traits::is_dereferenceable&lt; Iterator2 &gt;, traits::is_equality_comparable&lt; daw::traits::deref_t&lt; Iterator2 &gt;&gt;&gt;&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::satisfies_one </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator2&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicates &amp;&amp;...&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any function returns true for any value in range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the beginning of the range inclusively </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to the end of the range exclusively </td></tr>
    <tr><td class="paramname">func</td><td>A UnaryPredicate that returns true/false </td></tr>
    <tr><td class="paramname">funcs</td><td>UnaryPredicates that return true/false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any of the func/funcs return true(e.g. like OR) for any value in range </dd></dl>

</div>
</div>
<a id="a6fbb987aa9c647ee766c92a89dfa58a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbb987aa9c647ee766c92a89dfa58a4">&#9670;&nbsp;</a></span>satisfies_one() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::satisfies_one </td>
          <td>(</td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any function returns true for the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><a class="el" href="structdaw_1_1_argument.html">Argument</a> to UnaryPredicate </td></tr>
    <tr><td class="paramname">func</td><td>A UnaryPredicate that returns true/false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of func </dd></dl>

</div>
</div>
<a id="a4f323e3f8e391bed4be78902876b0cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f323e3f8e391bed4be78902876b0cc5">&#9670;&nbsp;</a></span>satisfies_one() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value , typename UnaryPredicate , typename... UnaryPredicates&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool daw::algorithm::satisfies_one </td>
          <td>(</td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicates &amp;&amp;...&#160;</td>
          <td class="paramname"><em>funcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any function returns true for the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><a class="el" href="structdaw_1_1_argument.html">Argument</a> to UnaryPredicate(s) </td></tr>
    <tr><td class="paramname">func</td><td>A UnaryPredicate that returns true/false </td></tr>
    <tr><td class="paramname">funcs</td><td>UnaryPredicates that return true/false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any of the func/funcs return true(e.g. like OR) </dd></dl>

</div>
</div>
<a id="a39afc7d4832cc57b7c30d2cf15b26f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39afc7d4832cc57b7c30d2cf15b26f8d">&#9670;&nbsp;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename Compare  = std::equal_to&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator1 daw::algorithm::search </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>s_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator2&#160;</td>
          <td class="paramname"><em>s_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a11f1eba0c20a57886c073282e245f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a11f1eba0c20a57886c073282e245f8">&#9670;&nbsp;</a></span>set_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename OutputIterator , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::set_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f58b789aa4f592313969f3f5ac88d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f58b789aa4f592313969f3f5ac88d68">&#9670;&nbsp;</a></span>slide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt;ForwardIterator, ForwardIterator&gt; daw::algorithm::slide </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55e6374ecee31a3d5860518d09cc64d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e6374ecee31a3d5860518d09cc64d1">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; daw::algorithm::sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac832fc0c8968fc6f466a1e6ec37a3a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac832fc0c8968fc6f466a1e6ec37a3a2e">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Compare , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; daw::algorithm::sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf409c6068ef2dc471f46becfec26232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf409c6068ef2dc471f46becfec26232">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto daw::algorithm::split </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60d3df4c9be5533e07818f559125981f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d3df4c9be5533e07818f559125981f">&#9670;&nbsp;</a></span>stable_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto daw::algorithm::stable_partition </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype( begin( container ) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a404824b87e278b18d53e232ddfc67892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404824b87e278b18d53e232ddfc67892">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; daw::algorithm::stable_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9434215e39dd8d41f9c86dbc15bad52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9434215e39dd8d41f9c86dbc15bad52e">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Compare , std::enable_if_t&lt; traits::is_container_like_v&lt; Container &gt;, std::nullptr_t &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; daw::algorithm::stable_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ad054e7ae76c97db42dcf1df8324300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad054e7ae76c97db42dcf1df8324300">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename LastType , typename OutputIterator , typename UnaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform range [first, last) and output to range [first_out, first_out + std::distance( first, last )) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a></td><td>input range iterator type </td></tr>
    <tr><td class="paramname">LastType</td><td>type of Iterator marking end of input range </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>output range iterator type </td></tr>
    <tr><td class="paramname">UnaryOperation</td><td>callable that takes the dereferenced value from input range and is assignable to the dereferenced value of output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first element in input range [first, first + count) </td></tr>
    <tr><td class="paramname">last</td><td>end of input range </td></tr>
    <tr><td class="paramname">first_out</td><td>first element in output range [first_out, first_out + count) </td></tr>
    <tr><td class="paramname">unary_op</td><td>callable that transforms items from input range to items of output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last item in output range </dd></dl>

</div>
</div>
<a id="a1292d41269e8059fd8c4fd565f6df08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1292d41269e8059fd8c4fd565f6df08b">&#9670;&nbsp;</a></span>transform_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename LastType , typename OutputIterator , typename UnaryPredicate , typename TransformFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::transform_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType const&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransformFunction&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the TransformFunction on the value referenced by range [first, last) when the predicate returns true for that value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>Type of Iterator for start of range </td></tr>
    <tr><td class="paramname">LastType</td><td>Type for representing end of range </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>Iterator for output range </td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>A unary predicate that takes the dereferenced <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> as an arugment </td></tr>
    <tr><td class="paramname">TransformFunction</td><td>Takes the dereferenced <a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a> as an arugment and returns a value assignable to the dereferenced OutputIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first item in range [first, last) </td></tr>
    <tr><td class="paramname">last</td><td>last item in range [first, last) </td></tr>
    <tr><td class="paramname">first_out</td><td>Output iterator written to when predicate returns true </td></tr>
    <tr><td class="paramname">pred</td><td>predicate to determine if a transform should happen </td></tr>
    <tr><td class="paramname">trans</td><td>transform function to convert from input range to output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output range </dd></dl>

</div>
</div>
<a id="a32d6b07b72b208da43f982e51fe912e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d6b07b72b208da43f982e51fe912e7">&#9670;&nbsp;</a></span>transform_it()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename LastType , typename OutputIterator , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIterator daw::algorithm::transform_it </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LastType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform input range [first, last) to output range [first_out, first_out + std::distance(first, last)). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a></td><td>type of Iterator of input range </td></tr>
    <tr><td class="paramname">LastType</td><td>type of Iterator marking end of input range </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>type of iterator for output range </td></tr>
    <tr><td class="paramname">BinaryOperation</td><td>a callable that takes the type of the dereference input range iterator and the output range as argument, returning the next position in output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>start of input range </td></tr>
    <tr><td class="paramname">last</td><td>end of input range </td></tr>
    <tr><td class="paramname">first_out</td><td>first item in output range </td></tr>
    <tr><td class="paramname">binary_op</td><td>transformation function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end of output range written to </dd></dl>

</div>
</div>
<a id="af57d6d8db61ee7a9a6af8d30999acb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57d6d8db61ee7a9a6af8d30999acb19">&#9670;&nbsp;</a></span>transform_many() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename InputIt3 , typename InputIt4 , typename InputIt5 , typename OutputIt , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIt daw::algorithm::transform_many </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt3&#160;</td>
          <td class="paramname"><em>first3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt4&#160;</td>
          <td class="paramname"><em>first4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt4&#160;</td>
          <td class="paramname"><em>first5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab8a70d6c991394488d046801ae5e943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8a70d6c991394488d046801ae5e943">&#9670;&nbsp;</a></span>transform_many() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename InputIt3 , typename InputIt4 , typename OutputIt , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIt daw::algorithm::transform_many </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt3&#160;</td>
          <td class="paramname"><em>first3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt4&#160;</td>
          <td class="paramname"><em>first4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae081a7fb4de4a66ada5795adc738196f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae081a7fb4de4a66ada5795adc738196f">&#9670;&nbsp;</a></span>transform_many() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename InputIt3 , typename OutputIt , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIt daw::algorithm::transform_many </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt3&#160;</td>
          <td class="paramname"><em>first3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d7626aa527e1bf8a47c22225d5c12e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7626aa527e1bf8a47c22225d5c12e9">&#9670;&nbsp;</a></span>transform_many() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr OutputIt daw::algorithm::transform_many </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa485a04daaccb007febfd11ea60a80da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa485a04daaccb007febfd11ea60a80da">&#9670;&nbsp;</a></span>transform_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename UnaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto daw::algorithm::transform_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>first_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the transform function unary_op on n elements of range started by first. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a></td><td>input range iterator type </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>output range iterator type </td></tr>
    <tr><td class="paramname">UnaryOperation</td><td>callable that takes the dereferenced value from input range and is assignable to the dereferenced value of output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first element in input range [first, first + count) </td></tr>
    <tr><td class="paramname">first_out</td><td>first element in output range [first_out, first_out + count) </td></tr>
    <tr><td class="paramname">count</td><td>number of items to process </td></tr>
    <tr><td class="paramname">unary_op</td><td>callable that transforms items from input range to items of output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last item in output range </dd></dl>

</div>
</div>
<a id="a5e5bdd633d26ab5d52424e7b7cdbe056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5bdd633d26ab5d52424e7b7cdbe056">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T , typename Compare  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ForwardIterator daw::algorithm::upper_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Compare{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the range [first, last) that is greater than value, or last if no such element is found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>Iteratot type pointing to range </td></tr>
    <tr><td class="paramname">T</td><td>a value comparable to the dereferenced <a class="el" href="structdaw_1_1_random_iterator.html">RandomIterator</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first item in range </td></tr>
    <tr><td class="paramname">last</td><td>end of range </td></tr>
    <tr><td class="paramname">value</td><td>value to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of first element greater than value or last </dd></dl>

</div>
</div>
<a id="adec592b6450f709e3666765ba90a5645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec592b6450f709e3666765ba90a5645">&#9670;&nbsp;</a></span>where() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto daw::algorithm::where </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbddafa5870ff0db531cae3f3b8b3526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbddafa5870ff0db531cae3f3b8b3526">&#9670;&nbsp;</a></span>where() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto daw::algorithm::where </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdaw_1_1_input_iterator.html">InputIterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
