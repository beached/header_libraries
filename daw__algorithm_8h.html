<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DAW Header Libraries: daw_algorithm.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DAW Header Libraries
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_bbe37f38b13c9c6d535338573ad492f6.html">daw</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">daw_algorithm.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="ciso646_8h_source.html">ciso646.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cpp__17_8h_source.html">cpp_17.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="daw__compiler__fixups_8h_source.html">daw_compiler_fixups.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="daw__do__n_8h_source.html">daw_do_n.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="daw__enable__if_8h_source.html">daw_enable_if.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="daw__exception_8h_source.html">daw_exception.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="daw__move_8h_source.html">daw_move.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="daw__swap_8h_source.html">daw_swap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="daw__traits_8h_source.html">daw_traits.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="daw__view_8h_source.html">daw_view.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="daw__math__impl_8h_source.html">impl/daw_math_impl.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="daw__algorithm_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1all__equal.html">daw::algorithm::all_equal&lt; Compare &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1find__one__of__result.html">daw::algorithm::find_one_of_result&lt; Iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1find__some__result.html">daw::algorithm::find_some_result&lt; Iterator, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1tuple__functor.html">daw::algorithm::tuple_functor&lt; N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdaw_1_1algorithm_1_1tuple__functor_3_010_01_4.html">daw::algorithm::tuple_functor&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedaw"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedaw.html">daw</a></td></tr>
<tr class="memdesc:namespacedaw"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a class to validate a type T after construction Validator must return true if the value is valid, false otherwise. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedaw_1_1algorithm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html">daw::algorithm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4a2f99ef2a0c36731f352b3f5c0c860a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename T &gt; </td></tr>
<tr class="memitem:a4a2f99ef2a0c36731f352b3f5c0c860a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4a2f99ef2a0c36731f352b3f5c0c860a">daw::algorithm::accumulate</a> (InputIterator first, InputIterator last, T init) noexcept</td></tr>
<tr class="separator:a4a2f99ef2a0c36731f352b3f5c0c860a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944826cf0164d4f289c579cd6668cda5"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename T , typename BinaryOperation  = std::plus&lt;&gt;, daw::enable_when_t&lt; not daw::traits::is_container_like_v&lt; InputIterator &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a944826cf0164d4f289c579cd6668cda5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a944826cf0164d4f289c579cd6668cda5">daw::algorithm::accumulate</a> (InputIterator first, LastType last, T init, BinaryOperation binary_op=BinaryOperation{ }) noexcept(noexcept(binary_op(<a class="el" href="daw__move_8h.html#a5707fa464976f991a156ac6a583a135c">DAW_MOVE</a>(init), *first)))</td></tr>
<tr class="separator:a944826cf0164d4f289c579cd6668cda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce45ed0b83d6e8567b52d36fc657f7c"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a5ce45ed0b83d6e8567b52d36fc657f7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a5ce45ed0b83d6e8567b52d36fc657f7c">daw::algorithm::adjacent_find</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate p)</td></tr>
<tr class="separator:a5ce45ed0b83d6e8567b52d36fc657f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19885f1427079df07f015229b7b3313"><td class="memTemplParams" colspan="2">template&lt;typename Distance , typename Iterator &gt; </td></tr>
<tr class="memitem:ae19885f1427079df07f015229b7b3313"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#ae19885f1427079df07f015229b7b3313">daw::advance_many</a> (Distance d, Iterator &amp;it)</td></tr>
<tr class="separator:ae19885f1427079df07f015229b7b3313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd798599dd45a407e433693c249541f"><td class="memTemplParams" colspan="2">template&lt;typename Distance , typename Iterator , typename Iterator2 , typename... Iterators&gt; </td></tr>
<tr class="memitem:a7fd798599dd45a407e433693c249541f"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#a7fd798599dd45a407e433693c249541f">daw::advance_many</a> (Distance d, Iterator &amp;it, Iterator2 &amp;it2, Iterators &amp;...its)</td></tr>
<tr class="separator:a7fd798599dd45a407e433693c249541f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66611fc5fedbe3d14da8ea48712e44e8"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a66611fc5fedbe3d14da8ea48712e44e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a66611fc5fedbe3d14da8ea48712e44e8">daw::algorithm::all_of</a> (InputIt first, InputIt last, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="separator:a66611fc5fedbe3d14da8ea48712e44e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e831e99ec1f0f3c7b138bb79df1ada"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a34e831e99ec1f0f3c7b138bb79df1ada"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a34e831e99ec1f0f3c7b138bb79df1ada">daw::algorithm::any_of</a> (InputIt first, InputIt last, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="separator:a34e831e99ec1f0f3c7b138bb79df1ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3c93707622a8f926e4e99dd578533b"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a6f3c93707622a8f926e4e99dd578533b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a6f3c93707622a8f926e4e99dd578533b">daw::algorithm::are_equal</a> (ValueType v1, ValueType v2)</td></tr>
<tr class="separator:a6f3c93707622a8f926e4e99dd578533b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526f0fd8877b4122a679ebf85e9553ae"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename... Values&gt; </td></tr>
<tr class="memitem:a526f0fd8877b4122a679ebf85e9553ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a526f0fd8877b4122a679ebf85e9553ae">daw::algorithm::are_equal</a> (ValueType v1, ValueType v2, Values... others)</td></tr>
<tr class="separator:a526f0fd8877b4122a679ebf85e9553ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a813d8fe12a8644442bdf00f0d1a26"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a55a813d8fe12a8644442bdf00f0d1a26"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a55a813d8fe12a8644442bdf00f0d1a26">daw::algorithm::are_equal</a> (ValueType) noexcept</td></tr>
<tr class="separator:a55a813d8fe12a8644442bdf00f0d1a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8779e979a0b87a99b522146a26b6ed"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a3e8779e979a0b87a99b522146a26b6ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#a3e8779e979a0b87a99b522146a26b6ed">daw::begin_at</a> (Container &amp;container, size_t n) noexcept(noexcept(std::begin(container))) -&gt; decltype(std::begin(container))</td></tr>
<tr class="memdesc:a3e8779e979a0b87a99b522146a26b6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take iterator return from begin of a container and return the result of running next with n steps.  <a href="namespacedaw.html#a3e8779e979a0b87a99b522146a26b6ed">More...</a><br /></td></tr>
<tr class="separator:a3e8779e979a0b87a99b522146a26b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379ef1361fbe8d2401f1628536637e9a"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a379ef1361fbe8d2401f1628536637e9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#a379ef1361fbe8d2401f1628536637e9a">daw::begin_at</a> (Container const &amp;container, size_t n) noexcept(noexcept(std::cbegin(container))) -&gt; decltype(std::cbegin(container))</td></tr>
<tr class="memdesc:a379ef1361fbe8d2401f1628536637e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take iterator return from begin of a container and return the result of running next with n steps.  <a href="namespacedaw.html#a379ef1361fbe8d2401f1628536637e9a">More...</a><br /></td></tr>
<tr class="separator:a379ef1361fbe8d2401f1628536637e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a64c490e32e63c61f3f9a36ef6337f4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Value , typename Predicate  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a0a64c490e32e63c61f3f9a36ef6337f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a0a64c490e32e63c61f3f9a36ef6337f4">daw::algorithm::binary_search</a> (ForwardIterator first, ForwardIterator const last, Value &amp;&amp;value, Predicate less_than=Predicate{ })</td></tr>
<tr class="separator:a0a64c490e32e63c61f3f9a36ef6337f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348a380774f14182c1f647ba814adfa7"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Iterator1 , typename LastType , typename... Iterators&gt; </td></tr>
<tr class="memitem:a348a380774f14182c1f647ba814adfa7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a348a380774f14182c1f647ba814adfa7">daw::algorithm::cartesian_product</a> (Function func, Iterator1 first1, LastType last1, Iterators... its)</td></tr>
<tr class="separator:a348a380774f14182c1f647ba814adfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a912de415d15db927d02ceaa983dd9"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Iterator1 , typename LastType , typename OutputIterator , typename... Iterators&gt; </td></tr>
<tr class="memitem:a83a912de415d15db927d02ceaa983dd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a83a912de415d15db927d02ceaa983dd9">daw::algorithm::cartesian_product_map</a> (Function func, Iterator1 first1, LastType last1, OutputIterator out_it, Iterators... its)</td></tr>
<tr class="separator:a83a912de415d15db927d02ceaa983dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21745db3448f2a269c864edf85bd62b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21745db3448f2a269c864edf85bd62b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a21745db3448f2a269c864edf85bd62b3">daw::algorithm::clamp</a> (T &amp;&amp;value, T &amp;&amp;max_value) noexcept</td></tr>
<tr class="separator:a21745db3448f2a269c864edf85bd62b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090d47b5916cea6cbd755fd3ef090e8e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename LessCompare  = std::less&lt;&gt;, typename Equality  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a090d47b5916cea6cbd755fd3ef090e8e"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a090d47b5916cea6cbd755fd3ef090e8e">daw::algorithm::compare_range</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, LessCompare less_comp=LessCompare{ }, Equality eq=Equality{ })</td></tr>
<tr class="separator:a090d47b5916cea6cbd755fd3ef090e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f192b6ccebd06eef1a7338e08b7c666"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class UnaryPredicate , typename Function &gt; </td></tr>
<tr class="memitem:a2f192b6ccebd06eef1a7338e08b7c666"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a2f192b6ccebd06eef1a7338e08b7c666">daw::algorithm::consume_if</a> (ForwardIterator first, ForwardIterator last, UnaryPredicate &amp;&amp;pred, Function &amp;&amp;func) noexcept(noexcept(<a class="el" href="namespacedaw.html#aaf04bbb17a0eb3df0e77509eadfffb09">daw::invoke</a>(pred, *first)))</td></tr>
<tr class="separator:a2f192b6ccebd06eef1a7338e08b7c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1404bf7eb1420ef148da26efa6f803d"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Last , typename Value , typename Compare  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:ae1404bf7eb1420ef148da26efa6f803d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ae1404bf7eb1420ef148da26efa6f803d">daw::algorithm::contains</a> (Iterator first, Last last, Value const &amp;value, Compare cmp=Compare{ })</td></tr>
<tr class="separator:ae1404bf7eb1420ef148da26efa6f803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b606fb08f1bc0ccd92715572f58f281"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Last , typename Predicate &gt; </td></tr>
<tr class="memitem:a3b606fb08f1bc0ccd92715572f58f281"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3b606fb08f1bc0ccd92715572f58f281">daw::algorithm::contains_if</a> (Iterator first, Last last, Predicate pred)</td></tr>
<tr class="separator:a3b606fb08f1bc0ccd92715572f58f281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3507b19c52691aee70a61f643650c963"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a3507b19c52691aee70a61f643650c963"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3507b19c52691aee70a61f643650c963">daw::algorithm::copy</a> (InputIterator first, LastType last, OutputIterator first_out) noexcept(noexcept(*first_out= *first))</td></tr>
<tr class="memdesc:a3507b19c52691aee70a61f643650c963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy input range [first, last) to output range [first_out, first_out + std::distance( first, last ))  <a href="namespacedaw_1_1algorithm.html#a3507b19c52691aee70a61f643650c963">More...</a><br /></td></tr>
<tr class="separator:a3507b19c52691aee70a61f643650c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b66509bae10796c6b1d708e6d164f8"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a98b66509bae10796c6b1d708e6d164f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a98b66509bae10796c6b1d708e6d164f8">daw::algorithm::copy_if</a> (InputIterator first, LastType last, OutputIterator destination, UnaryPredicate pred)</td></tr>
<tr class="memdesc:a98b66509bae10796c6b1d708e6d164f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy input range [first, last) to output range [first_out, first_out + std::distance( first, last ))  <a href="namespacedaw_1_1algorithm.html#a98b66509bae10796c6b1d708e6d164f8">More...</a><br /></td></tr>
<tr class="separator:a98b66509bae10796c6b1d708e6d164f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a00ad34966c36b58a030e80006c1128"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a5a00ad34966c36b58a030e80006c1128"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a5a00ad34966c36b58a030e80006c1128">daw::algorithm::copy_n</a> (InputIterator first, OutputIterator first_out, size_t count) noexcept(noexcept(*first_out= *first))</td></tr>
<tr class="memdesc:a5a00ad34966c36b58a030e80006c1128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy input range [first, last) to output range [first_out, first_out + count)  <a href="namespacedaw_1_1algorithm.html#a5a00ad34966c36b58a030e80006c1128">More...</a><br /></td></tr>
<tr class="separator:a5a00ad34966c36b58a030e80006c1128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f1366a0264fb7e78a69fd808323884"><td class="memTemplParams" colspan="2">template&lt;typename ResultType  = size_t, typename Iterator , typename Last , typename Predicate &gt; </td></tr>
<tr class="memitem:a32f1366a0264fb7e78a69fd808323884"><td class="memTemplItemLeft" align="right" valign="top">constexpr ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a32f1366a0264fb7e78a69fd808323884">daw::algorithm::count_if</a> (Iterator first, Last last, Predicate pred)</td></tr>
<tr class="separator:a32f1366a0264fb7e78a69fd808323884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7180d7d1c698717a28885b05c85dd3ac"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a7180d7d1c698717a28885b05c85dd3ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a7180d7d1c698717a28885b05c85dd3ac">daw::algorithm::crbegin2</a> (Container &amp;container) noexcept(noexcept(container.crbegin())) -&gt; decltype(container.crbegin())</td></tr>
<tr class="separator:a7180d7d1c698717a28885b05c85dd3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad36f82cf3ff81c74893fd7c225b469"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a7ad36f82cf3ff81c74893fd7c225b469"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a7ad36f82cf3ff81c74893fd7c225b469">daw::algorithm::crend2</a> (Container &amp;container) noexcept(noexcept(container.crend())) -&gt; decltype(container.crend())</td></tr>
<tr class="separator:a7ad36f82cf3ff81c74893fd7c225b469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246406c231020051364312c9eb824ad7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType , typename InputIterator2 &gt; </td></tr>
<tr class="memitem:a246406c231020051364312c9eb824ad7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a246406c231020051364312c9eb824ad7">daw::algorithm::equal</a> (InputIterator1 first1, LastType last1, InputIterator2 first2)</td></tr>
<tr class="memdesc:a246406c231020051364312c9eb824ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two ranges [first1, last1) and [first2, first2 + std::distance( first1, last1 )) are equal.  <a href="namespacedaw_1_1algorithm.html#a246406c231020051364312c9eb824ad7">More...</a><br /></td></tr>
<tr class="separator:a246406c231020051364312c9eb824ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d098bbb4a1afa6660dbf3153330b15a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename Compare  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a8d098bbb4a1afa6660dbf3153330b15a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a8d098bbb4a1afa6660dbf3153330b15a">daw::algorithm::equal</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, Compare comp=Compare{ })</td></tr>
<tr class="memdesc:a8d098bbb4a1afa6660dbf3153330b15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two ranges [first1, last1) and [first2, last2) using pred.  <a href="namespacedaw_1_1algorithm.html#a8d098bbb4a1afa6660dbf3153330b15a">More...</a><br /></td></tr>
<tr class="separator:a8d098bbb4a1afa6660dbf3153330b15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cf92a01383de6938e84056452e8a05"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:ac1cf92a01383de6938e84056452e8a05"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac1cf92a01383de6938e84056452e8a05">daw::algorithm::equal_to</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:ac1cf92a01383de6938e84056452e8a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is equal to value construct with.  <a href="namespacedaw_1_1algorithm.html#ac1cf92a01383de6938e84056452e8a05">More...</a><br /></td></tr>
<tr class="separator:ac1cf92a01383de6938e84056452e8a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3380b4219cf95fb5b74f441afc16e05"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:ac3380b4219cf95fb5b74f441afc16e05"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac3380b4219cf95fb5b74f441afc16e05">daw::algorithm::extract_all</a> (From &amp;from, To &amp;to)</td></tr>
<tr class="separator:ac3380b4219cf95fb5b74f441afc16e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8316026229df93894eb788b14510ca"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To , typename Predicate &gt; </td></tr>
<tr class="memitem:afa8316026229df93894eb788b14510ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#afa8316026229df93894eb788b14510ca">daw::algorithm::extract_matching</a> (From &amp;from, To &amp;to, Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:afa8316026229df93894eb788b14510ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d032668855cbd0593ca1393fb4b101"><td class="memTemplParams" colspan="2">template&lt;typename From , typename To , typename Query &gt; </td></tr>
<tr class="memitem:a19d032668855cbd0593ca1393fb4b101"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a19d032668855cbd0593ca1393fb4b101">daw::algorithm::extract_to</a> (From &amp;from, To &amp;to, Query &amp;&amp;q)</td></tr>
<tr class="separator:a19d032668855cbd0593ca1393fb4b101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8010cb04005c183297ce128a7b145d3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename T &gt; </td></tr>
<tr class="memitem:ac8010cb04005c183297ce128a7b145d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac8010cb04005c183297ce128a7b145d3">daw::algorithm::fill</a> (ForwardIterator first, LastType last, T &amp;&amp;value) noexcept</td></tr>
<tr class="separator:ac8010cb04005c183297ce128a7b145d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13372842c98a0c5fa1c9412a96fcee9"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ab13372842c98a0c5fa1c9412a96fcee9"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ab13372842c98a0c5fa1c9412a96fcee9">daw::algorithm::fill_n</a> (ForwardIterator first, size_t count, T &amp;&amp;value) noexcept</td></tr>
<tr class="separator:ab13372842c98a0c5fa1c9412a96fcee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06482e2d72b0abd493f5f06b8bc3ec"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class T &gt; </td></tr>
<tr class="memitem:a9f06482e2d72b0abd493f5f06b8bc3ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a9f06482e2d72b0abd493f5f06b8bc3ec">daw::algorithm::find</a> (InputIterator first, InputIterator last, T const &amp;value)</td></tr>
<tr class="separator:a9f06482e2d72b0abd493f5f06b8bc3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d08fe8bdbb44123d9900af874c5b4a5"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a4d08fe8bdbb44123d9900af874c5b4a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4d08fe8bdbb44123d9900af874c5b4a5">daw::algorithm::find_first_of</a> (InputIterator first, InputIterator last, ForwardIterator sfirst, ForwardIterator slast)</td></tr>
<tr class="separator:a4d08fe8bdbb44123d9900af874c5b4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14820bbe71e6c36f83a44266f1351fea"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a14820bbe71e6c36f83a44266f1351fea"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a14820bbe71e6c36f83a44266f1351fea">daw::algorithm::find_first_of</a> (InputIterator first, InputIterator last, UnaryPredicate pred)</td></tr>
<tr class="separator:a14820bbe71e6c36f83a44266f1351fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9421dd35db72d4a8d1ccc2f5a576c1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aff9421dd35db72d4a8d1ccc2f5a576c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aff9421dd35db72d4a8d1ccc2f5a576c1">daw::algorithm::find_first_range_of</a> (Iterator first, Iterator const last, UnaryPredicate pred)</td></tr>
<tr class="separator:aff9421dd35db72d4a8d1ccc2f5a576c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107922750a7d50071fff62745825ba6d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename InputIteratorLast , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a107922750a7d50071fff62745825ba6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a107922750a7d50071fff62745825ba6d">daw::algorithm::find_if</a> (InputIterator first, InputIteratorLast last, UnaryPredicate &amp;&amp;unary_predicate)</td></tr>
<tr class="separator:a107922750a7d50071fff62745825ba6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd788ba1aab1318928d89a64aef094a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a1cd788ba1aab1318928d89a64aef094a"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a1cd788ba1aab1318928d89a64aef094a">daw::algorithm::find_if_not</a> (InputIterator first, InputIterator last, UnaryPredicate &amp;&amp;unary_predicate)</td></tr>
<tr class="separator:a1cd788ba1aab1318928d89a64aef094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0895670e01db5c74181a6a26ace22e4b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:a0895670e01db5c74181a6a26ace22e4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a0895670e01db5c74181a6a26ace22e4b">daw::algorithm::find_index</a> (Iterator first, Iterator last, T const &amp;value)</td></tr>
<tr class="separator:a0895670e01db5c74181a6a26ace22e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49df3aa19b5d30ce7f018213549367c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ab49df3aa19b5d30ce7f018213549367c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::optional&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ab49df3aa19b5d30ce7f018213549367c">daw::algorithm::find_index_if</a> (Iterator first, Iterator last, Predicate &amp;&amp;pred)</td></tr>
<tr class="separator:ab49df3aa19b5d30ce7f018213549367c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605d5f9e4d2ac3c7339817d614f0d259"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename IteratorLast , typename Value &gt; </td></tr>
<tr class="memitem:a605d5f9e4d2ac3c7339817d614f0d259"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a605d5f9e4d2ac3c7339817d614f0d259">daw::algorithm::find_index_of</a> (Iterator first, IteratorLast last, Value const &amp;v)</td></tr>
<tr class="separator:a605d5f9e4d2ac3c7339817d614f0d259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054f2fc6592a4b795b3b9c3900144048"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename IteratorLast , typename Predicate &gt; </td></tr>
<tr class="memitem:a054f2fc6592a4b795b3b9c3900144048"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a054f2fc6592a4b795b3b9c3900144048">daw::algorithm::find_index_of_if</a> (Iterator first, IteratorLast last, Predicate pred)</td></tr>
<tr class="separator:a054f2fc6592a4b795b3b9c3900144048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a78b56b4a11e134c5dfb9e317519be"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aa3a78b56b4a11e134c5dfb9e317519be"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aa3a78b56b4a11e134c5dfb9e317519be">daw::algorithm::find_last_of</a> (ForwardIterator first, ForwardIterator const last, UnaryPredicate pred)</td></tr>
<tr class="separator:aa3a78b56b4a11e134c5dfb9e317519be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ecf4a930f958b9190a4ab1cf738c0b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename IteratorLast , typename... Predicates&gt; </td></tr>
<tr class="memitem:a42ecf4a930f958b9190a4ab1cf738c0b"><td class="memTemplItemLeft" align="right" valign="top">find_one_of_result&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a42ecf4a930f958b9190a4ab1cf738c0b">daw::algorithm::find_one_of</a> (Iterator first, IteratorLast last, Predicates... preds)</td></tr>
<tr class="separator:a42ecf4a930f958b9190a4ab1cf738c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e61beb897641a94d20400972aa17243"><td class="memTemplParams" colspan="2">template&lt;typename IteratorF , typename IteratorL , typename... Predicates&gt; </td></tr>
<tr class="memitem:a8e61beb897641a94d20400972aa17243"><td class="memTemplItemLeft" align="right" valign="top">constexpr find_some_result&lt; IteratorF, sizeof...(Predicates)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a8e61beb897641a94d20400972aa17243">daw::algorithm::find_some</a> (IteratorF first, IteratorL last, Predicates &amp;&amp;...preds)</td></tr>
<tr class="separator:a8e61beb897641a94d20400972aa17243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27487c6c7d5f7603dd35efa431c3ea6b"><td class="memTemplParams" colspan="2">template&lt;typename RandomIterator , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a27487c6c7d5f7603dd35efa431c3ea6b"><td class="memTemplItemLeft" align="right" valign="top">RandomIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a27487c6c7d5f7603dd35efa431c3ea6b">daw::algorithm::find_unsorted</a> (RandomIterator first, RandomIterator last, Compare comp=Compare{ })</td></tr>
<tr class="separator:a27487c6c7d5f7603dd35efa431c3ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae909b17db10006c20761ac386f5bbb"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Predicate , typename OnEach &gt; </td></tr>
<tr class="memitem:a3ae909b17db10006c20761ac386f5bbb"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3ae909b17db10006c20761ac386f5bbb">daw::algorithm::for_each_if</a> (Iterator first, Iterator last, Predicate pred, OnEach onEach)</td></tr>
<tr class="memdesc:a3ae909b17db10006c20761ac386f5bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a predicate is satisfied, call onEach with the read value.  <a href="namespacedaw_1_1algorithm.html#a3ae909b17db10006c20761ac386f5bbb">More...</a><br /></td></tr>
<tr class="separator:a3ae909b17db10006c20761ac386f5bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f5d2227d8c9e154951a177ae86cb8"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a925f5d2227d8c9e154951a177ae86cb8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; ForwardIterator, ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a925f5d2227d8c9e154951a177ae86cb8">daw::algorithm::gather</a> (ForwardIterator first, ForwardIterator last, ForwardIterator target, Predicate predicate)</td></tr>
<tr class="separator:a925f5d2227d8c9e154951a177ae86cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a6bcb616b2870be290d9f9b7870733"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a31a6bcb616b2870be290d9f9b7870733"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a31a6bcb616b2870be290d9f9b7870733">daw::algorithm::greater_than</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:a31a6bcb616b2870be290d9f9b7870733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is greater than the value constructed with.  <a href="namespacedaw_1_1algorithm.html#a31a6bcb616b2870be290d9f9b7870733">More...</a><br /></td></tr>
<tr class="separator:a31a6bcb616b2870be290d9f9b7870733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc10d9c646795a2f99e6f22ce4108313"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:afc10d9c646795a2f99e6f22ce4108313"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#afc10d9c646795a2f99e6f22ce4108313">daw::algorithm::greater_than_or_equal_to</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:afc10d9c646795a2f99e6f22ce4108313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is greater than or equal to the value constructed with.  <a href="namespacedaw_1_1algorithm.html#afc10d9c646795a2f99e6f22ce4108313">More...</a><br /></td></tr>
<tr class="separator:afc10d9c646795a2f99e6f22ce4108313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870e8b9cb223d68f886824b9a6ed6cbd"><td class="memTemplParams" colspan="2">template&lt;typename Lower , typename Upper &gt; </td></tr>
<tr class="memitem:a870e8b9cb223d68f886824b9a6ed6cbd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a870e8b9cb223d68f886824b9a6ed6cbd">daw::algorithm::in_range</a> (Lower &amp;&amp;lower, Upper &amp;&amp;upper)</td></tr>
<tr class="memdesc:a870e8b9cb223d68f886824b9a6ed6cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if the value passed is in the range [Lower, Upper].  <a href="namespacedaw_1_1algorithm.html#a870e8b9cb223d68f886824b9a6ed6cbd">More...</a><br /></td></tr>
<tr class="separator:a870e8b9cb223d68f886824b9a6ed6cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb32b7361c18f6dd2a7dac4a158044a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename EndIterator , typename T &gt; </td></tr>
<tr class="memitem:a2cb32b7361c18f6dd2a7dac4a158044a"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a2cb32b7361c18f6dd2a7dac4a158044a">daw::algorithm::iota</a> (Iterator first, EndIterator last, T start_value)</td></tr>
<tr class="separator:a2cb32b7361c18f6dd2a7dac4a158044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f54470b45dba1e12229ce4c9c67ae76"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename EndIterator , typename T , typename Setter &gt; </td></tr>
<tr class="memitem:a4f54470b45dba1e12229ce4c9c67ae76"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4f54470b45dba1e12229ce4c9c67ae76">daw::algorithm::iota</a> (Iterator first, EndIterator last, T start_value, Setter setter)</td></tr>
<tr class="separator:a4f54470b45dba1e12229ce4c9c67ae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9879e8a4c8d33f22a3b8c77504a01898"><td class="memTemplParams" colspan="2">template&lt;typename Ptr &gt; </td></tr>
<tr class="memitem:a9879e8a4c8d33f22a3b8c77504a01898"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a9879e8a4c8d33f22a3b8c77504a01898">daw::algorithm::is_null_ptr</a> (Ptr const *const ptr) noexcept</td></tr>
<tr class="separator:a9879e8a4c8d33f22a3b8c77504a01898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e700e320d0a724be3dee6bb0578418"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a18e700e320d0a724be3dee6bb0578418"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a18e700e320d0a724be3dee6bb0578418">daw::algorithm::is_sorted</a> (ForwardIterator first, LastType last, Compare comp=Compare{ }) noexcept(noexcept(comp(*first, *first)))</td></tr>
<tr class="separator:a18e700e320d0a724be3dee6bb0578418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af352d0f3c7349e76832859c5990225fa"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:af352d0f3c7349e76832859c5990225fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af352d0f3c7349e76832859c5990225fa">daw::algorithm::is_sorted_until</a> (ForwardIterator first, ForwardIterator last, Compare comp=Compare{ }) noexcept(noexcept(comp(*first, *first)))</td></tr>
<tr class="memdesc:af352d0f3c7349e76832859c5990225fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in ascending order.  <a href="namespacedaw_1_1algorithm.html#af352d0f3c7349e76832859c5990225fa">More...</a><br /></td></tr>
<tr class="separator:af352d0f3c7349e76832859c5990225fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4097b557f4ac677bf241413b41aaa8ef"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a4097b557f4ac677bf241413b41aaa8ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4097b557f4ac677bf241413b41aaa8ef">daw::algorithm::is_sorted_until</a> (ForwardIterator first, LastType last, Compare comp=Compare{ }) noexcept(noexcept(comp(*first, *first)))</td></tr>
<tr class="separator:a4097b557f4ac677bf241413b41aaa8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e03635467f2e3edd2a5e22d130594c"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a54e03635467f2e3edd2a5e22d130594c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a54e03635467f2e3edd2a5e22d130594c">daw::algorithm::less_than</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:a54e03635467f2e3edd2a5e22d130594c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is less than the value constructed with.  <a href="namespacedaw_1_1algorithm.html#a54e03635467f2e3edd2a5e22d130594c">More...</a><br /></td></tr>
<tr class="separator:a54e03635467f2e3edd2a5e22d130594c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918f6bdda424bc90d3a2f78e0c29a4a0"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a918f6bdda424bc90d3a2f78e0c29a4a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a918f6bdda424bc90d3a2f78e0c29a4a0">daw::algorithm::less_than_or_equal_to</a> (Value &amp;&amp;value)</td></tr>
<tr class="memdesc:a918f6bdda424bc90d3a2f78e0c29a4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a callable that returns true if value passed is less than or equal to the value constructed with.  <a href="namespacedaw_1_1algorithm.html#a918f6bdda424bc90d3a2f78e0c29a4a0">More...</a><br /></td></tr>
<tr class="separator:a918f6bdda424bc90d3a2f78e0c29a4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7296f91f3fc8a8bbf1db649ab8b4f91e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a7296f91f3fc8a8bbf1db649ab8b4f91e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a7296f91f3fc8a8bbf1db649ab8b4f91e">daw::algorithm::lexicographical_compare</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, Compare comp=Compare{ }) noexcept(noexcept(comp(*first1, *first2) !=comp(*first2, *first1)))</td></tr>
<tr class="memdesc:a7296f91f3fc8a8bbf1db649ab8b4f91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first range [first1, last1) is lexigraphically less than the second range [first2, last2)  <a href="namespacedaw_1_1algorithm.html#a7296f91f3fc8a8bbf1db649ab8b4f91e">More...</a><br /></td></tr>
<tr class="separator:a7296f91f3fc8a8bbf1db649ab8b4f91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6248697fdfb467e6156d382a9651000"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Value , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:ab6248697fdfb467e6156d382a9651000"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ab6248697fdfb467e6156d382a9651000">daw::algorithm::lower_bound</a> (ForwardIterator first, ForwardIterator last, Value &amp;&amp;value, Compare cmp={ })</td></tr>
<tr class="separator:ab6248697fdfb467e6156d382a9651000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e353a0bcfae6ff014273ee36625c5c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:aa8e353a0bcfae6ff014273ee36625c5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aa8e353a0bcfae6ff014273ee36625c5c">daw::algorithm::map</a> (InputIterator first, InputIterator const last, OutputIterator first_out, UnaryOperation unary_op) noexcept(noexcept(*<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first_out)=unary_op(*<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first))))</td></tr>
<tr class="separator:aa8e353a0bcfae6ff014273ee36625c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0e16fb0f656262688fe8efb808328f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a9d0e16fb0f656262688fe8efb808328f"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a9d0e16fb0f656262688fe8efb808328f">daw::algorithm::map</a> (InputIterator1 first1, InputIterator1 const last1, InputIterator2 first2, OutputIterator first_out, BinaryOperation binary_op) noexcept(noexcept(*<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first_out)=binary_op(*<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first1), *<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(first2))))</td></tr>
<tr class="separator:a9d0e16fb0f656262688fe8efb808328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b614738de5163d3705ff9fdc0e0d4f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator1Last , typename InputIterator2 , typename T , typename ReduceFunction , typename MapFunction &gt; </td></tr>
<tr class="memitem:a07b614738de5163d3705ff9fdc0e0d4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a07b614738de5163d3705ff9fdc0e0d4f">daw::algorithm::map_reduce</a> (InputIterator1 first1, InputIterator1Last last1, InputIterator2 first2, T init, ReduceFunction reduce_func, MapFunction map_func) noexcept(noexcept(reduce_func(init, map_func(*first1, *first2))))</td></tr>
<tr class="separator:a07b614738de5163d3705ff9fdc0e0d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c7c25ed11d5c2976ddc6eba620fb8"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:ac44c7c25ed11d5c2976ddc6eba620fb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac44c7c25ed11d5c2976ddc6eba620fb8">daw::algorithm::max_element</a> (ForwardIterator first, ForwardIterator last, Compare &amp;&amp;comp=Compare{ })</td></tr>
<tr class="separator:ac44c7c25ed11d5c2976ddc6eba620fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac171acbaaa03ff1f07a7d6bae7af8718"><td class="memTemplParams" colspan="2">template&lt;typename Lhs &gt; </td></tr>
<tr class="memitem:ac171acbaaa03ff1f07a7d6bae7af8718"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ac171acbaaa03ff1f07a7d6bae7af8718">daw::algorithm::max_item</a> (Lhs const &amp;lhs) noexcept</td></tr>
<tr class="separator:ac171acbaaa03ff1f07a7d6bae7af8718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205aad3634c60325f74970a882f41f4a"><td class="memTemplParams" colspan="2">template&lt;typename Lhs , typename... Ts, daw::enable_when_t&lt;(sizeof...(Ts) &gt; 0)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a205aad3634c60325f74970a882f41f4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a205aad3634c60325f74970a882f41f4a">daw::algorithm::max_item</a> (Lhs const &amp;lhs, Ts const &amp;...ts) noexcept</td></tr>
<tr class="separator:a205aad3634c60325f74970a882f41f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfacfb5361ce5f0f86758465d06bbf84"><td class="memTemplParams" colspan="2">template&lt;typename Lhs &gt; </td></tr>
<tr class="memitem:acfacfb5361ce5f0f86758465d06bbf84"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#acfacfb5361ce5f0f86758465d06bbf84">daw::algorithm::min_item</a> (Lhs const &amp;lhs) noexcept</td></tr>
<tr class="separator:acfacfb5361ce5f0f86758465d06bbf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618e894c7d1342f261312e27c70dda8b"><td class="memTemplParams" colspan="2">template&lt;typename Lhs , typename... Ts, daw::enable_when_t&lt;(sizeof...(Ts) &gt; 0)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a618e894c7d1342f261312e27c70dda8b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a618e894c7d1342f261312e27c70dda8b">daw::algorithm::min_item</a> (Lhs const &amp;lhs, Ts const &amp;...ts) noexcept</td></tr>
<tr class="separator:a618e894c7d1342f261312e27c70dda8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bf17243f1114998ba23aac7f5bdcec"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a96bf17243f1114998ba23aac7f5bdcec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a96bf17243f1114998ba23aac7f5bdcec">daw::algorithm::minmax_element</a> (ForwardIterator first, LastType last, Compare comp=Compare{ }) noexcept(noexcept(comp(*first, *first)))</td></tr>
<tr class="separator:a96bf17243f1114998ba23aac7f5bdcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e424d2a4b80fc2a5d7f956670b24036"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a4e424d2a4b80fc2a5d7f956670b24036"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4e424d2a4b80fc2a5d7f956670b24036">daw::algorithm::minmax_item</a> (T a, T b, Compare comp=Compare{ }) noexcept</td></tr>
<tr class="memdesc:a4e424d2a4b80fc2a5d7f956670b24036"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the min and max of two items sorted  <a href="namespacedaw_1_1algorithm.html#a4e424d2a4b80fc2a5d7f956670b24036">More...</a><br /></td></tr>
<tr class="separator:a4e424d2a4b80fc2a5d7f956670b24036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cc7fd2597e2ff7aa90f65271dae2e6"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ad2cc7fd2597e2ff7aa90f65271dae2e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ad2cc7fd2597e2ff7aa90f65271dae2e6">daw::algorithm::move</a> (InputIterator first, LastType const last, OutputIterator first_out) noexcept(noexcept(*first_out=<a class="el" href="daw__move_8h.html#a5707fa464976f991a156ac6a583a135c">DAW_MOVE</a>(*first)))</td></tr>
<tr class="memdesc:ad2cc7fd2597e2ff7aa90f65271dae2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move values from input range [first, last) to output range [first_out, std::distance( first, last))  <a href="namespacedaw_1_1algorithm.html#ad2cc7fd2597e2ff7aa90f65271dae2e6">More...</a><br /></td></tr>
<tr class="separator:ad2cc7fd2597e2ff7aa90f65271dae2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10898183c4796c63bdf78afb724b3ff0"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a10898183c4796c63bdf78afb724b3ff0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a10898183c4796c63bdf78afb724b3ff0">daw::algorithm::move_n</a> (InputIterator first, OutputIterator first_out, size_t count) noexcept(noexcept(*first_out=<a class="el" href="daw__move_8h.html#a5707fa464976f991a156ac6a583a135c">DAW_MOVE</a>(*first)))</td></tr>
<tr class="memdesc:a10898183c4796c63bdf78afb724b3ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move values from input range [first, last) to output range [first_out, first_out + count)  <a href="namespacedaw_1_1algorithm.html#a10898183c4796c63bdf78afb724b3ff0">More...</a><br /></td></tr>
<tr class="separator:a10898183c4796c63bdf78afb724b3ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3048b1af33a628f53d0215c2d9c13350"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a3048b1af33a628f53d0215c2d9c13350"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3048b1af33a628f53d0215c2d9c13350">daw::algorithm::none_of</a> (InputIt first, InputIt last, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="separator:a3048b1af33a628f53d0215c2d9c13350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf0fc9776642df4c7ffdf6b35ab80ad"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType , typename InputIterator2 &gt; </td></tr>
<tr class="memitem:aabf0fc9776642df4c7ffdf6b35ab80ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aabf0fc9776642df4c7ffdf6b35ab80ad">daw::algorithm::not_equal</a> (InputIterator1 first1, LastType last1, InputIterator2 first2)</td></tr>
<tr class="memdesc:aabf0fc9776642df4c7ffdf6b35ab80ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two ranges [first1, last1) and [first2, first2 + std::distance( first1, last1 )) are equal.  <a href="namespacedaw_1_1algorithm.html#aabf0fc9776642df4c7ffdf6b35ab80ad">More...</a><br /></td></tr>
<tr class="separator:aabf0fc9776642df4c7ffdf6b35ab80ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670de991496fd97b1760dbc45903af23"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename Compare  = std::not_equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a670de991496fd97b1760dbc45903af23"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a670de991496fd97b1760dbc45903af23">daw::algorithm::not_equal</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, Compare comp=Compare{ })</td></tr>
<tr class="memdesc:a670de991496fd97b1760dbc45903af23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two ranges [first1, last1) and [first2, last2) using pred.  <a href="namespacedaw_1_1algorithm.html#a670de991496fd97b1760dbc45903af23">More...</a><br /></td></tr>
<tr class="separator:a670de991496fd97b1760dbc45903af23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea63be89b34ecad9efac4efd09c514e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryOperator  = std::plus&lt;&gt;&gt; </td></tr>
<tr class="memitem:adea63be89b34ecad9efac4efd09c514e"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#adea63be89b34ecad9efac4efd09c514e">daw::algorithm::partial_sum</a> (InputIterator first, InputIterator last, OutputIterator first_out, BinaryOperator op=BinaryOperator{ })</td></tr>
<tr class="separator:adea63be89b34ecad9efac4efd09c514e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2016dccce680b2fd954e7e83e2c7f18e"><td class="memTemplParams" colspan="2">template&lt;size_t MinSize = 1, typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:a2016dccce680b2fd954e7e83e2c7f18e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdaw_1_1view.html">daw::view</a>&lt; BidirectionalIterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a2016dccce680b2fd954e7e83e2c7f18e">daw::algorithm::partition_range</a> (BidirectionalIterator first, BidirectionalIterator last, size_t count)</td></tr>
<tr class="separator:a2016dccce680b2fd954e7e83e2c7f18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f374b624c0fa8cf2faea4569e641cab"><td class="memTemplParams" colspan="2">template&lt;size_t MinSize = 1, typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:a9f374b624c0fa8cf2faea4569e641cab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdaw_1_1view.html">daw::view</a>&lt; BidirectionalIterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a9f374b624c0fa8cf2faea4569e641cab">daw::algorithm::partition_range</a> (<a class="el" href="structdaw_1_1view.html">daw::view</a>&lt; BidirectionalIterator &gt; rng, size_t count)</td></tr>
<tr class="separator:a9f374b624c0fa8cf2faea4569e641cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dc5ab2970864d9126cfa3761c67089"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:af6dc5ab2970864d9126cfa3761c67089"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af6dc5ab2970864d9126cfa3761c67089">daw::algorithm::rbegin2</a> (Container &amp;container) noexcept(noexcept(container.rbegin())) -&gt; decltype(container.rbegin())</td></tr>
<tr class="separator:af6dc5ab2970864d9126cfa3761c67089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d03f2e8e610c08c3b62cf9aba10fc4a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename RandomIterator , typename RandomIteratorLast , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a0d03f2e8e610c08c3b62cf9aba10fc4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a0d03f2e8e610c08c3b62cf9aba10fc4a">daw::algorithm::reduce</a> (RandomIterator first, RandomIteratorLast last, T init, BinaryOperation binary_op) noexcept(noexcept(init=binary_op(init, *first++)))</td></tr>
<tr class="separator:a0d03f2e8e610c08c3b62cf9aba10fc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7ac4effdfa4fadaa4b3aca4da36b7d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ade7ac4effdfa4fadaa4b3aca4da36b7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ade7ac4effdfa4fadaa4b3aca4da36b7d">daw::algorithm::remove</a> (ForwardIterator first, ForwardIterator last, T const &amp;value)</td></tr>
<tr class="separator:ade7ac4effdfa4fadaa4b3aca4da36b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641675b8cc5170dc309d7174bba53695"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a641675b8cc5170dc309d7174bba53695"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a641675b8cc5170dc309d7174bba53695">daw::algorithm::remove_if</a> (ForwardIterator first, ForwardIterator last, UnaryPredicate &amp;&amp;pred) noexcept(noexcept(<a class="el" href="namespacedaw.html#aaf04bbb17a0eb3df0e77509eadfffb09">daw::invoke</a>(pred, *first)))</td></tr>
<tr class="separator:a641675b8cc5170dc309d7174bba53695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17895ecdb30772d8471144e47350d3e0"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a17895ecdb30772d8471144e47350d3e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a17895ecdb30772d8471144e47350d3e0">daw::algorithm::rend2</a> (Container &amp;container) noexcept(noexcept(container.rend())) -&gt; decltype(container.rend())</td></tr>
<tr class="separator:a17895ecdb30772d8471144e47350d3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a0d6d0676b624ca3cd8690216021a4"><td class="memTemplParams" colspan="2">template&lt;typename BidirectionalIterator &gt; </td></tr>
<tr class="memitem:af2a0d6d0676b624ca3cd8690216021a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af2a0d6d0676b624ca3cd8690216021a4">daw::algorithm::reverse</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="separator:af2a0d6d0676b624ca3cd8690216021a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36c227a8190a418258d5b491f551a72"><td class="memTemplParams" colspan="2">template&lt;typename Fwd &gt; </td></tr>
<tr class="memitem:af36c227a8190a418258d5b491f551a72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af36c227a8190a418258d5b491f551a72">daw::algorithm::reverse</a> (Fwd &amp;&amp;fwd) -&gt; decltype(algorithm_details::reverse_impl(fwd, int(0)))</td></tr>
<tr class="separator:af36c227a8190a418258d5b491f551a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ad0bbd2262d67ab99c77e6d489fc59"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Iterator , typename Distance &gt; </td></tr>
<tr class="memitem:ab0ad0bbd2262d67ab99c77e6d489fc59"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#ab0ad0bbd2262d67ab99c77e6d489fc59">daw::safe_advance</a> (Container &amp;container, Iterator &amp;it, Distance distance) noexcept</td></tr>
<tr class="memdesc:ab0ad0bbd2262d67ab99c77e6d489fc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance Iterator within the bounds of container.  <a href="namespacedaw.html#ab0ad0bbd2262d67ab99c77e6d489fc59">More...</a><br /></td></tr>
<tr class="separator:ab0ad0bbd2262d67ab99c77e6d489fc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7f2f9e5660f46243f2efe724a2a4cc"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Iterator , typename Distance &gt; </td></tr>
<tr class="memitem:a9d7f2f9e5660f46243f2efe724a2a4cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#a9d7f2f9e5660f46243f2efe724a2a4cc">daw::safe_advance</a> (Container const &amp;container, Iterator &amp;it, Distance distance) noexcept</td></tr>
<tr class="memdesc:a9d7f2f9e5660f46243f2efe724a2a4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance Iterator within the bounds of container.  <a href="namespacedaw.html#a9d7f2f9e5660f46243f2efe724a2a4cc">More...</a><br /></td></tr>
<tr class="separator:a9d7f2f9e5660f46243f2efe724a2a4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162c26f1473a434b0d1a514ec38af070"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Distance  = size_t&gt; </td></tr>
<tr class="memitem:a162c26f1473a434b0d1a514ec38af070"><td class="memTemplItemLeft" align="right" valign="top">constexpr Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#a162c26f1473a434b0d1a514ec38af070">daw::safe_next</a> (Iterator it, Iterator const last, Distance n=1U) noexcept(noexcept(<a class="el" href="namespacedaw.html#a55399937a2ff351c8338d513521b00e1">daw::next</a>(it, static_cast&lt; std::ptrdiff_t &gt;(n))))</td></tr>
<tr class="memdesc:a162c26f1473a434b0d1a514ec38af070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance iterator n steps forward but do not go past last. Undefined if it &gt; last.  <a href="namespacedaw.html#a162c26f1473a434b0d1a514ec38af070">More...</a><br /></td></tr>
<tr class="separator:a162c26f1473a434b0d1a514ec38af070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847ce71f0bf8ea0c1f96e2f2faca34d0"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Distance &gt; </td></tr>
<tr class="memitem:a847ce71f0bf8ea0c1f96e2f2faca34d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#a847ce71f0bf8ea0c1f96e2f2faca34d0">daw::safe_prev</a> (Iterator it, Iterator first, Distance n=1) noexcept(noexcept(<a class="el" href="namespacedaw.html#a6e8d238a833c171fca8ca8edba7b3c3f">daw::prev</a>(it, static_cast&lt; std::ptrdiff_t &gt;(n))))</td></tr>
<tr class="memdesc:a847ce71f0bf8ea0c1f96e2f2faca34d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance iterator n steps backward but do not go past first. Undefined if it &lt; first.  <a href="namespacedaw.html#a847ce71f0bf8ea0c1f96e2f2faca34d0">More...</a><br /></td></tr>
<tr class="separator:a847ce71f0bf8ea0c1f96e2f2faca34d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfb08f27b60ffc7031e8c71038cfc73"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Iterator2 , typename UnaryPredicate , typename... UnaryPredicates, daw::enable_when_t&lt; std::conjunction_v&lt; traits::is_dereferenceable&lt; Iterator2 &gt;, traits::is_equality_comparable&lt; daw::traits::deref_t&lt; Iterator2 &gt;&gt;&gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a0cfb08f27b60ffc7031e8c71038cfc73"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a0cfb08f27b60ffc7031e8c71038cfc73">daw::algorithm::satisfies_all</a> (Iterator first, Iterator2 last, UnaryPredicate &amp;&amp;func, UnaryPredicates &amp;&amp;...funcs) noexcept(noexcept(satisfies_one(*first, func, funcs...)))</td></tr>
<tr class="memdesc:a0cfb08f27b60ffc7031e8c71038cfc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all function(s) returns true for all values in range.  <a href="namespacedaw_1_1algorithm.html#a0cfb08f27b60ffc7031e8c71038cfc73">More...</a><br /></td></tr>
<tr class="separator:a0cfb08f27b60ffc7031e8c71038cfc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadb413768e40a33315892b555d789e0"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aaadb413768e40a33315892b555d789e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aaadb413768e40a33315892b555d789e0">daw::algorithm::satisfies_all</a> (Value &amp;&amp;value, UnaryPredicate &amp;&amp;func) noexcept(noexcept(func(value)))</td></tr>
<tr class="memdesc:aaadb413768e40a33315892b555d789e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if function returns true for the value.  <a href="namespacedaw_1_1algorithm.html#aaadb413768e40a33315892b555d789e0">More...</a><br /></td></tr>
<tr class="separator:aaadb413768e40a33315892b555d789e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd15058c7a84e8b3fb14e71e415b5fa"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename UnaryPredicate , typename... UnaryPredicates&gt; </td></tr>
<tr class="memitem:aafd15058c7a84e8b3fb14e71e415b5fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aafd15058c7a84e8b3fb14e71e415b5fa">daw::algorithm::satisfies_all</a> (Value &amp;&amp;value, UnaryPredicate &amp;&amp;func, UnaryPredicates &amp;&amp;...funcs)</td></tr>
<tr class="memdesc:aafd15058c7a84e8b3fb14e71e415b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all function(s) returns true for the value.  <a href="namespacedaw_1_1algorithm.html#aafd15058c7a84e8b3fb14e71e415b5fa">More...</a><br /></td></tr>
<tr class="separator:aafd15058c7a84e8b3fb14e71e415b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f3d04f92b332d02a3d09a0bed966e6"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Iterator2 , typename UnaryPredicate , typename... UnaryPredicates, daw::enable_when_t&lt; std::conjunction_v&lt; traits::is_dereferenceable&lt; Iterator2 &gt;, traits::is_equality_comparable&lt; daw::traits::deref_t&lt; Iterator2 &gt;&gt;&gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a02f3d04f92b332d02a3d09a0bed966e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a02f3d04f92b332d02a3d09a0bed966e6">daw::algorithm::satisfies_one</a> (Iterator first, Iterator2 last, UnaryPredicate &amp;&amp;func, UnaryPredicates &amp;&amp;...funcs) noexcept(noexcept(satisfies_one(*first, func, funcs...)))</td></tr>
<tr class="memdesc:a02f3d04f92b332d02a3d09a0bed966e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any function returns true for any value in range.  <a href="namespacedaw_1_1algorithm.html#a02f3d04f92b332d02a3d09a0bed966e6">More...</a><br /></td></tr>
<tr class="separator:a02f3d04f92b332d02a3d09a0bed966e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbb987aa9c647ee766c92a89dfa58a4"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a6fbb987aa9c647ee766c92a89dfa58a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a6fbb987aa9c647ee766c92a89dfa58a4">daw::algorithm::satisfies_one</a> (Value &amp;&amp;value, UnaryPredicate &amp;&amp;func) noexcept(noexcept(func(value)))</td></tr>
<tr class="memdesc:a6fbb987aa9c647ee766c92a89dfa58a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any function returns true for the value.  <a href="namespacedaw_1_1algorithm.html#a6fbb987aa9c647ee766c92a89dfa58a4">More...</a><br /></td></tr>
<tr class="separator:a6fbb987aa9c647ee766c92a89dfa58a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f323e3f8e391bed4be78902876b0cc5"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename UnaryPredicate , typename... UnaryPredicates&gt; </td></tr>
<tr class="memitem:a4f323e3f8e391bed4be78902876b0cc5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a4f323e3f8e391bed4be78902876b0cc5">daw::algorithm::satisfies_one</a> (Value &amp;&amp;value, UnaryPredicate &amp;&amp;func, UnaryPredicates &amp;&amp;...funcs)</td></tr>
<tr class="memdesc:a4f323e3f8e391bed4be78902876b0cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any function returns true for the value.  <a href="namespacedaw_1_1algorithm.html#a4f323e3f8e391bed4be78902876b0cc5">More...</a><br /></td></tr>
<tr class="separator:a4f323e3f8e391bed4be78902876b0cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39afc7d4832cc57b7c30d2cf15b26f8d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename Compare  = std::equal_to&lt;&gt;&gt; </td></tr>
<tr class="memitem:a39afc7d4832cc57b7c30d2cf15b26f8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a39afc7d4832cc57b7c30d2cf15b26f8d">daw::algorithm::search</a> (ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 s_first, ForwardIterator2 s_last, Compare comp=Compare{ }) noexcept(noexcept(not comp(*first, *s_first)))</td></tr>
<tr class="separator:a39afc7d4832cc57b7c30d2cf15b26f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a11f1eba0c20a57886c073282e245f8"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename LastType1 , typename InputIterator2 , typename LastType2 , typename OutputIterator , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a1a11f1eba0c20a57886c073282e245f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a1a11f1eba0c20a57886c073282e245f8">daw::algorithm::set_intersection</a> (InputIterator1 first1, LastType1 last1, InputIterator2 first2, LastType2 last2, OutputIterator d_first, Compare &amp;&amp;comp=Compare{ }) noexcept(noexcept(comp(*first2, *first1)) and noexcept(comp(*first1, *first2)))</td></tr>
<tr class="separator:a1a11f1eba0c20a57886c073282e245f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf409c6068ef2dc471f46becfec26232"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Value &gt; </td></tr>
<tr class="memitem:aaf409c6068ef2dc471f46becfec26232"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aaf409c6068ef2dc471f46becfec26232">daw::algorithm::split</a> (Iterator first, Iterator last, Value const &amp;value)</td></tr>
<tr class="separator:aaf409c6068ef2dc471f46becfec26232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad054e7ae76c97db42dcf1df8324300"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a3ad054e7ae76c97db42dcf1df8324300"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a3ad054e7ae76c97db42dcf1df8324300">daw::algorithm::transform</a> (InputIterator first, LastType last, OutputIterator first_out, UnaryOperation unary_op) noexcept(std::is_nothrow_constructible_v&lt; decltype(*first_out), decltype(unary_op(*first))&gt;)</td></tr>
<tr class="memdesc:a3ad054e7ae76c97db42dcf1df8324300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform range [first, last) and output to range [first_out, first_out + std::distance( first, last ))  <a href="namespacedaw_1_1algorithm.html#a3ad054e7ae76c97db42dcf1df8324300">More...</a><br /></td></tr>
<tr class="separator:a3ad054e7ae76c97db42dcf1df8324300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1292d41269e8059fd8c4fd565f6df08b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename LastType , typename OutputIterator , typename UnaryPredicate , typename TransformFunction &gt; </td></tr>
<tr class="memitem:a1292d41269e8059fd8c4fd565f6df08b"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a1292d41269e8059fd8c4fd565f6df08b">daw::algorithm::transform_if</a> (ForwardIterator first, LastType const last, OutputIterator first_out, UnaryPredicate pred, TransformFunction trans)</td></tr>
<tr class="memdesc:a1292d41269e8059fd8c4fd565f6df08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the TransformFunction on the value referenced by range [first, last) when the predicate returns true for that value.  <a href="namespacedaw_1_1algorithm.html#a1292d41269e8059fd8c4fd565f6df08b">More...</a><br /></td></tr>
<tr class="separator:a1292d41269e8059fd8c4fd565f6df08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d6b07b72b208da43f982e51fe912e7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename LastType , typename OutputIterator , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a32d6b07b72b208da43f982e51fe912e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a32d6b07b72b208da43f982e51fe912e7">daw::algorithm::transform_it</a> (InputIterator first, LastType last, OutputIterator first_out, BinaryOperation binary_op) noexcept(noexcept(first_out=binary_op(*first++, first_out)))</td></tr>
<tr class="memdesc:a32d6b07b72b208da43f982e51fe912e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform input range [first, last) to output range [first_out, first_out + std::distance(first, last)).  <a href="namespacedaw_1_1algorithm.html#a32d6b07b72b208da43f982e51fe912e7">More...</a><br /></td></tr>
<tr class="separator:a32d6b07b72b208da43f982e51fe912e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57d6d8db61ee7a9a6af8d30999acb19"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename InputIt3 , typename InputIt4 , typename InputIt5 , typename OutputIt , typename Func &gt; </td></tr>
<tr class="memitem:af57d6d8db61ee7a9a6af8d30999acb19"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#af57d6d8db61ee7a9a6af8d30999acb19">daw::algorithm::transform_many</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt3 first3, InputIt4 first4, InputIt4 first5, OutputIt first_out, Func func)</td></tr>
<tr class="separator:af57d6d8db61ee7a9a6af8d30999acb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8a70d6c991394488d046801ae5e943"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename InputIt3 , typename InputIt4 , typename OutputIt , typename Func &gt; </td></tr>
<tr class="memitem:aab8a70d6c991394488d046801ae5e943"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aab8a70d6c991394488d046801ae5e943">daw::algorithm::transform_many</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt3 first3, InputIt4 first4, OutputIt first_out, Func func)</td></tr>
<tr class="separator:aab8a70d6c991394488d046801ae5e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae081a7fb4de4a66ada5795adc738196f"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename InputIt3 , typename OutputIt , typename Func &gt; </td></tr>
<tr class="memitem:ae081a7fb4de4a66ada5795adc738196f"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#ae081a7fb4de4a66ada5795adc738196f">daw::algorithm::transform_many</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt3 first3, OutputIt first_out, Func func)</td></tr>
<tr class="separator:ae081a7fb4de4a66ada5795adc738196f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7626aa527e1bf8a47c22225d5c12e9"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Func &gt; </td></tr>
<tr class="memitem:a5d7626aa527e1bf8a47c22225d5c12e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a5d7626aa527e1bf8a47c22225d5c12e9">daw::algorithm::transform_many</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt first_out, Func func)</td></tr>
<tr class="separator:a5d7626aa527e1bf8a47c22225d5c12e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa485a04daaccb007febfd11ea60a80da"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:aa485a04daaccb007febfd11ea60a80da"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#aa485a04daaccb007febfd11ea60a80da">daw::algorithm::transform_n</a> (InputIterator first, OutputIterator first_out, size_t count, UnaryOperation unary_op) noexcept(noexcept(*first_out=unary_op(*first)))</td></tr>
<tr class="memdesc:aa485a04daaccb007febfd11ea60a80da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the transform function unary_op on n elements of range started by first.  <a href="namespacedaw_1_1algorithm.html#aa485a04daaccb007febfd11ea60a80da">More...</a><br /></td></tr>
<tr class="separator:aa485a04daaccb007febfd11ea60a80da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505e955d1a6e2b08f76f38c96bf28dab"><td class="memTemplParams" colspan="2">template&lt;typename Map , typename Key &gt; </td></tr>
<tr class="memitem:a505e955d1a6e2b08f76f38c96bf28dab"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#a505e955d1a6e2b08f76f38c96bf28dab">daw::try_get</a> (Map &amp;container, Key &amp;&amp;k)</td></tr>
<tr class="separator:a505e955d1a6e2b08f76f38c96bf28dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed19f379fb9e454878e8e59522a6cd49"><td class="memTemplParams" colspan="2">template&lt;typename Map , typename Key &gt; </td></tr>
<tr class="memitem:aed19f379fb9e454878e8e59522a6cd49"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw.html#aed19f379fb9e454878e8e59522a6cd49">daw::try_get</a> (Map const &amp;container, Key &amp;&amp;k)</td></tr>
<tr class="separator:aed19f379fb9e454878e8e59522a6cd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5bdd633d26ab5d52424e7b7cdbe056"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T , typename Compare  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:a5e5bdd633d26ab5d52424e7b7cdbe056"><td class="memTemplItemLeft" align="right" valign="top">constexpr ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedaw_1_1algorithm.html#a5e5bdd633d26ab5d52424e7b7cdbe056">daw::algorithm::upper_bound</a> (ForwardIterator first, ForwardIterator last, T const &amp;value, Compare comp=Compare{ }) noexcept(noexcept(<a class="el" href="namespacedaw.html#a557cf75d8b8e24da975f31aa7a3dad69">daw::advance</a>(first, 1)) and noexcept(++first) and noexcept(<a class="el" href="namespacedaw.html#af12f9c7fb9774c53848cf8e9f721c828">daw::distance</a>(first, last)))</td></tr>
<tr class="memdesc:a5e5bdd633d26ab5d52424e7b7cdbe056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range [first, last) that is greater than value, or last if no such element is found.  <a href="namespacedaw_1_1algorithm.html#a5e5bdd633d26ab5d52424e7b7cdbe056">More...</a><br /></td></tr>
<tr class="separator:a5e5bdd633d26ab5d52424e7b7cdbe056"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
